(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
"use strict";

/**
 * Example ad integration using the videojs-ads plugin.
 *
 * For each content video, this plugin plays one preroll and one midroll.
 * Ad content is chosen randomly from the URLs listed in inventory.json.
 */
(function (window, document, vjs, undefined) {
  "use strict";

  var registerPlugin = vjs.registerPlugin || vjs.plugin;

  /**
   * Register the ad integration plugin.
   * To initialize for a player, call player.exampleAds().
   *
   * @param {mixed} options Hash of obtions for the exampleAds plugin.
   */
  registerPlugin('exampleAds', function (options) {

    var player = this,


    // example plugin state, may have any of these properties:
    //  - inventory - hypothetical ad inventory, list of URLs to ads
    //  - lastTime - the last time observed during content playback
    //  - adPlaying - whether a linear ad is currently playing
    //  - prerollPlayed - whether we've played a preroll
    //  - midrollPlayed - whether we've played a midroll
    //  - postrollPlayed - whether we've played a postroll
    state = {},


    // just like any other video.js plugin, ad integrations can
    // accept initialization options
    adServerUrl = options && options.adServerUrl || "inventory.json",
        midrollPoint = options && options.midrollPoint || 15,
        playPreroll = options && options.playPreroll !== undefined ? options.playPreroll : true,
        playMidroll = options && options.playMidroll !== undefined ? options.playMidroll : true,
        playPostroll = options && options.playPostroll !== undefined ? options.playPostroll : true,


    // asynchronous method for requesting ad inventory
    requestAds = function requestAds() {

      // reset plugin state
      state = {};

      // fetch ad inventory
      // the 'src' parameter is ignored by the example inventory.json flat file,
      // but this shows how you might send player information along to the ad server.
      var xhr = new XMLHttpRequest();
      xhr.open("GET", adServerUrl + "?src=" + encodeURIComponent(player.currentSrc()));
      xhr.onreadystatechange = function () {
        if (xhr.readyState === 4) {
          try {
            state.inventory = JSON.parse(xhr.responseText);
            player.trigger('adsready');
          } catch (err) {
            throw new Error('Couldn\'t parse inventory response as JSON');
          }
        }
      };
      xhr.send(null);
    },


    // play an ad, given an opportunity
    playAd = function playAd() {

      // short-circuit if we don't have any ad inventory to play
      if (!state.inventory || state.inventory.length === 0) {
        videojs.log('No inventory to play.');
        return;
      }

      // tell ads plugin we're ready to play our ad
      player.ads.startLinearAdMode();
      state.adPlaying = true;

      // tell videojs to load the ad
      var media = state.inventory[Math.floor(Math.random() * state.inventory.length)];
      player.src(media);

      // when it's finished
      player.one('adended', function () {
        // play your linear ad content, then when it's finished ...
        player.ads.endLinearAdMode();
        state.adPlaying = false;
      });
    };

    // initialize the ads plugin, passing in any relevant options
    player.ads(options);

    // request ad inventory whenever the player gets new content to play
    player.on('contentupdate', requestAds);
    // if there's already content loaded, request an add immediately
    if (player.currentSrc()) {
      requestAds();
    }

    player.on('contentended', function () {
      if (!state.postrollPlayed && player.ads.state === 'postroll?' && playPostroll) {
        state.postrollPlayed = true;
        playAd();
      }
    });

    // play an ad the first time there's a preroll opportunity
    player.on('readyforpreroll', function () {
      if (!state.prerollPlayed && playPreroll) {
        state.prerollPlayed = true;
        playAd();
      }
    });

    // watch for time to pass 15 seconds, then play an ad
    // if we haven't played a midroll already
    player.on('timeupdate', function (event) {

      if (state.midrollPlayed) {
        return;
      }

      var currentTime = player.currentTime(),
          opportunity;

      if ('lastTime' in state) {
        opportunity = currentTime > midrollPoint && state.lastTime < midrollPoint;
      }

      state.lastTime = currentTime;
      if (opportunity && playMidroll) {
        state.midrollPlayed = true;
        playAd();
      }
    });
  });
})(window, document, videojs);

},{}],2:[function(require,module,exports){
(function (global){
var win;

if (typeof window !== "undefined") {
    win = window;
} else if (typeof global !== "undefined") {
    win = global;
} else if (typeof self !== "undefined"){
    win = self;
} else {
    win = {};
}

module.exports = win;

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],3:[function(require,module,exports){
'use strict';

exports.__esModule = true;
exports['default'] = redispatch;
/*
The goal of this feature is to make player events work as an integrator would
expect despite the presense of ads. For example, an integrator would expect
an `ended` event to happen once the content is ended. If an `ended` event is sent
as a result of a preroll ending, that is a bug. The `redispatch` method should recognize
such `ended` events and prefix them so they are sent as `adended`, and so on with
all other player events.
*/

// Cancel an event.
// Video.js wraps native events. This technique stops propagation for the Video.js event
// (AKA player event or wrapper event) while native events continue propagating.
var cancelEvent = function cancelEvent(player, event) {
  event.isImmediatePropagationStopped = function () {
    return true;
  };
  event.cancelBubble = true;
  event.isPropagationStopped = function () {
    return true;
  };
};

// Redispatch an event with a prefix.
// Cancels the event, then sends a new event with the type of the original
// event with the given prefix added.
// The inclusion of the "state" property should be removed in a future
// major version update with instructions to migrate any code that relies on it.
// It is an implementation detail and relying on it creates fragility.
var prefixEvent = function prefixEvent(player, prefix, event) {
  cancelEvent(player, event);
  player.trigger({
    type: prefix + event.type,
    state: player.ads.state,
    originalEvent: event
  });
};

// Playing event
// Requirements:
// * Normal playing event when there is no preroll
// * No playing event before preroll
// * At least one playing event after preroll
// * A single adplaying event when an ad begins
var handlePlaying = function handlePlaying(player, event) {
  if (player.ads.isInAdMode()) {

    if (player.ads.isContentResuming()) {

      // Prefix playing event when switching back to content after postroll.
      if (player.ads._contentEnding) {
        prefixEvent(player, 'content', event);
      }

      // adplaying was already sent due to cancelContentPlay. Avoid sending another.
    } else if (player.ads._cancelledPlay) {
      cancelEvent(player, event);

      // Prefix all other playing events during ads.
    } else {
      prefixEvent(player, 'ad', event);
    }
  }
};

// Ended event
// Requirements:
// * A single ended event when there is no postroll
// * No ended event before postroll
// * A single ended event after postroll
var handleEnded = function handleEnded(player, event) {
  if (player.ads.isInAdMode()) {

    // The true ended event fired by plugin.js either after the postroll
    // or because there was no postroll.
    if (player.ads.isContentResuming()) {
      return;
    }

    // Prefix ended due to ad ending.
    prefixEvent(player, 'ad', event);
  } else {

    // Prefix ended due to content ending.
    prefixEvent(player, 'content', event);
  }
};

// handleLoadEvent is used for loadstart, loadeddata, and loadedmetadata
// Requirements:
// * Initial event is not prefixed
// * Event due to ad loading is prefixed
// * Event due to content source change is not prefixed
// * Event due to content resuming is prefixed
var handleLoadEvent = function handleLoadEvent(player, event) {

  // Initial event
  if (event.type === 'loadstart' && !player.ads._hasThereBeenALoadStartDuringPlayerLife || event.type === 'loadeddata' && !player.ads._hasThereBeenALoadedData || event.type === 'loadedmetadata' && !player.ads._hasThereBeenALoadedMetaData) {
    return;

    // Ad playing
  } else if (player.ads.isAdPlaying()) {
    prefixEvent(player, 'ad', event);

    // Source change
  } else if (player.currentSrc() !== player.ads.contentSrc) {
    return;

    // Content resuming
  } else {
    prefixEvent(player, 'content', event);
  }
};

// Play event
// Requirements:
// * Play events have the "ad" prefix when an ad is playing
// * Play events have the "content" prefix when content is resuming
// Play requests are unique because they represent user intention to play. They happen
// because the user clicked play, or someone called player.play(), etc. It could happen
// multiple times during ad loading, regardless of where we are in the process. With our
// current architecture, this will always cause the content to play. Therefor, contrib-ads
// must always cancelContentPlay if there is any possible chance the play caused the
// content to play, even if we are technically in ad mode. In order for that to happen,
// play events need to be unprefixed until the last possible moment. A better solution
// would be to have a way to intercept play events rather than "cancel" them by pausing
// after each one. To be continued...
var handlePlay = function handlePlay(player, event) {
  var resumingAfterNoPreroll = player.ads._cancelledPlay && !player.ads.isInAdMode();

  if (player.ads.isAdPlaying()) {
    prefixEvent(player, 'ad', event);
  } else if (player.ads.isContentResuming() || resumingAfterNoPreroll) {
    prefixEvent(player, 'content', event);
  }
};

// Handle a player event, either by redispatching it with a prefix, or by
// letting it go on its way without any meddling.
function redispatch(event) {

  // Events with special treatment
  if (event.type === 'playing') {
    handlePlaying(this, event);
  } else if (event.type === 'ended') {
    handleEnded(this, event);
  } else if (event.type === 'loadstart' || event.type === 'loadeddata' || event.type === 'loadedmetadata') {
    handleLoadEvent(this, event);
  } else if (event.type === 'play') {
    handlePlay(this, event);

    // Standard handling for all other events
  } else if (this.ads.isInAdMode()) {
    if (this.ads.isContentResuming()) {

      // Event came from snapshot restore after an ad, use "content" prefix
      prefixEvent(this, 'content', event);
    } else {

      // Event came from ad playback, use "ad" prefix
      prefixEvent(this, 'ad', event);
    }
  }
}

},{}],4:[function(require,module,exports){
(function (global){
'use strict';

exports.__esModule = true;
exports.getPlayerSnapshot = getPlayerSnapshot;
exports.restorePlayerSnapshot = restorePlayerSnapshot;

var _window = require('global/window');

var _window2 = _interopRequireDefault(_window);

var _video = (typeof window !== "undefined" ? window['videojs'] : typeof global !== "undefined" ? global['videojs'] : null);

var _video2 = _interopRequireDefault(_video);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

/**
 * Returns an object that captures the portions of player state relevant to
 * video playback. The result of this function can be passed to
 * restorePlayerSnapshot with a player to return the player to the state it
 * was in when this function was invoked.
 * @param {Object} player The videojs player object
 */
/*
The snapshot feature is responsible for saving the player state before an ad, then
restoring the player state after an ad.
*/

function getPlayerSnapshot(player) {

  var currentTime = void 0;

  if (_video2['default'].browser.IS_IOS && player.ads.isLive(player)) {
    // Record how far behind live we are
    if (player.seekable().length > 0) {
      currentTime = player.currentTime() - player.seekable().end(0);
    } else {
      currentTime = player.currentTime();
    }
  } else {
    currentTime = player.currentTime();
  }

  var tech = player.$('.vjs-tech');
  var remoteTracks = player.remoteTextTracks ? player.remoteTextTracks() : [];
  var tracks = player.textTracks ? player.textTracks() : [];
  var suppressedRemoteTracks = [];
  var suppressedTracks = [];
  var snapshotObject = {
    ended: player.ended(),
    currentSrc: player.currentSrc(),
    src: player.tech_.src(),
    currentTime: currentTime,
    type: player.currentType()
  };

  if (tech) {
    snapshotObject.nativePoster = tech.poster;
    snapshotObject.style = tech.getAttribute('style');
  }

  for (var i = 0; i < remoteTracks.length; i++) {
    var track = remoteTracks[i];

    suppressedRemoteTracks.push({
      track: track,
      mode: track.mode
    });
    track.mode = 'disabled';
  }
  snapshotObject.suppressedRemoteTracks = suppressedRemoteTracks;

  for (var _i = 0; _i < tracks.length; _i++) {
    var _track = tracks[_i];

    suppressedTracks.push({
      track: _track,
      mode: _track.mode
    });
    _track.mode = 'disabled';
  }
  snapshotObject.suppressedTracks = suppressedTracks;

  return snapshotObject;
}

/**
 * Attempts to modify the specified player so that its state is equivalent to
 * the state of the snapshot.
 * @param {Object} player - the videojs player object
 * @param {Object} snapshotObject - the player state to apply
 */
function restorePlayerSnapshot(player, snapshotObject) {

  if (player.ads.disableNextSnapshotRestore === true) {
    player.ads.disableNextSnapshotRestore = false;
    return;
  }

  // The playback tech
  var tech = player.$('.vjs-tech');

  // the number of[ remaining attempts to restore the snapshot
  var attempts = 20;

  var suppressedRemoteTracks = snapshotObject.suppressedRemoteTracks;
  var suppressedTracks = snapshotObject.suppressedTracks;
  var trackSnapshot = void 0;
  var restoreTracks = function restoreTracks() {
    for (var i = 0; i < suppressedRemoteTracks.length; i++) {
      trackSnapshot = suppressedRemoteTracks[i];
      trackSnapshot.track.mode = trackSnapshot.mode;
    }

    for (var _i2 = 0; _i2 < suppressedTracks.length; _i2++) {
      trackSnapshot = suppressedTracks[_i2];
      trackSnapshot.track.mode = trackSnapshot.mode;
    }
  };

  // finish restoring the playback state
  var resume = function resume() {
    var currentTime = void 0;

    if (_video2['default'].browser.IS_IOS && player.ads.isLive(player)) {
      if (snapshotObject.currentTime < 0) {
        // Playback was behind real time, so seek backwards to match
        if (player.seekable().length > 0) {
          currentTime = player.seekable().end(0) + snapshotObject.currentTime;
        } else {
          currentTime = player.currentTime();
        }
        player.currentTime(currentTime);
      }
    } else if (snapshotObject.ended) {
      player.currentTime(player.duration());
    } else {
      player.currentTime(snapshotObject.currentTime);
    }

    // Resume playback if this wasn't a postroll
    if (!snapshotObject.ended) {
      player.play();
    }
  };

  // determine if the video element has loaded enough of the snapshot source
  // to be ready to apply the rest of the state
  var tryToResume = function tryToResume() {

    // tryToResume can either have been called through the `contentcanplay`
    // event or fired through setTimeout.
    // When tryToResume is called, we should make sure to clear out the other
    // way it could've been called by removing the listener and clearing out
    // the timeout.
    player.off('contentcanplay', tryToResume);
    if (player.ads.tryToResumeTimeout_) {
      player.clearTimeout(player.ads.tryToResumeTimeout_);
      player.ads.tryToResumeTimeout_ = null;
    }

    // Tech may have changed depending on the differences in sources of the
    // original video and that of the ad
    tech = player.el().querySelector('.vjs-tech');

    if (tech.readyState > 1) {
      // some browsers and media aren't "seekable".
      // readyState greater than 1 allows for seeking without exceptions
      return resume();
    }

    if (tech.seekable === undefined) {
      // if the tech doesn't expose the seekable time ranges, try to
      // resume playback immediately
      return resume();
    }

    if (tech.seekable.length > 0) {
      // if some period of the video is seekable, resume playback
      return resume();
    }

    // delay a bit and then check again unless we're out of attempts
    if (attempts--) {
      _window2['default'].setTimeout(tryToResume, 50);
    } else {
      try {
        resume();
      } catch (e) {
        _video2['default'].log.warn('Failed to resume the content after an advertisement', e);
      }
    }
  };

  if (snapshotObject.nativePoster) {
    tech.poster = snapshotObject.nativePoster;
  }

  if ('style' in snapshotObject) {
    // overwrite all css style properties to restore state precisely
    tech.setAttribute('style', snapshotObject.style || '');
  }

  // Determine whether the player needs to be restored to its state
  // before ad playback began. With a custom ad display or burned-in
  // ads, the content player state hasn't been modified and so no
  // restoration is required

  if (player.ads.videoElementRecycled()) {
    // on ios7, fiddling with textTracks too early will cause safari to crash
    player.one('contentloadedmetadata', restoreTracks);

    // if the src changed for ad playback, reset it
    player.src({ src: snapshotObject.currentSrc, type: snapshotObject.type });

    // and then resume from the snapshots time once the original src has loaded
    // in some browsers (firefox) `canplay` may not fire correctly.
    // Reace the `canplay` event with a timeout.
    player.one('contentcanplay', tryToResume);
    player.ads.tryToResumeTimeout_ = player.setTimeout(tryToResume, 2000);
  } else if (!player.ended() || !snapshotObject.ended) {
    // if we didn't change the src, just restore the tracks
    restoreTracks();
    // the src didn't change and this wasn't a postroll
    // just resume playback at the current time.
    player.play();
  }
}

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"global/window":2}],5:[function(require,module,exports){
'use strict';

var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

var timerExists = function timerExists(env, keyOrId) {
  var timerId = _.isNumber(keyOrId) ? keyOrId : env.player.ads[String(keyOrId)];
  return env.clock.timers.hasOwnProperty(String(timerId));
};

QUnit.module('Ad Framework', window.sharedModuleHooks());

QUnit.test('begins in content-set', function (assert) {
  assert.expect(1);
  assert.strictEqual(this.player.ads.state, 'content-set');
});

QUnit.test('pauses to wait for prerolls when the plugin loads BEFORE play', function (assert) {
  var spy = sinon.spy(this.player, 'pause');

  assert.expect(1);

  this.player.paused = function () {
    return false;
  };

  this.player.trigger('adsready');
  this.player.trigger('play');
  this.clock.tick(1);
  this.player.trigger('play');
  this.clock.tick(1);
  assert.strictEqual(spy.callCount, 2, 'play attempts are paused');
});

QUnit.test('pauses to wait for prerolls when the plugin loads AFTER play', function (assert) {
  var pauseSpy;

  assert.expect(1);

  this.player.paused = function () {
    return false;
  };

  pauseSpy = sinon.spy(this.player, 'pause');
  this.player.trigger('play');
  this.clock.tick(1);
  this.player.trigger('play');
  this.clock.tick(1);
  assert.equal(pauseSpy.callCount, 2, 'play attempts are paused');
});

QUnit.test('stops canceling play events when an ad is playing', function (assert) {
  var setTimeoutSpy = sinon.spy(window, 'setTimeout');

  assert.expect(10);

  // Throughout this test, we check both that the expected timeouts are
  // populated on the `clock` _and_ that `setTimeout` has been called the
  // expected number of times.
  assert.notOk(timerExists(this, 'cancelPlayTimeout'), '`cancelPlayTimeout` does not exist');
  assert.notOk(timerExists(this, 'adTimeoutTimeout'), '`adTimeoutTimeout` does not exist');

  this.player.trigger('play');
  assert.strictEqual(setTimeoutSpy.callCount, 2, 'two timers were created (`cancelPlayTimeout` and `adTimeoutTimeout`)');
  assert.ok(timerExists(this, 'cancelPlayTimeout'), '`cancelPlayTimeout` exists');
  assert.ok(timerExists(this, 'adTimeoutTimeout'), '`adTimeoutTimeout` exists');

  this.player.trigger('adsready');
  assert.strictEqual(setTimeoutSpy.callCount, 3, '`adTimeoutTimeout` was re-scheduled');
  assert.ok(timerExists(this, 'adTimeoutTimeout'), '`adTimeoutTimeout` exists');

  this.clock.tick(1);

  this.player.trigger('adstart');
  assert.strictEqual(this.player.ads.state, 'ad-playback', 'ads are playing');
  assert.notOk(timerExists(this, 'adTimeoutTimeout'), '`adTimeoutTimeout` no longer exists');
  assert.notOk(timerExists(this, 'cancelPlayTimeout'), '`cancelPlayTimeout` no longer exists');

  window.setTimeout.restore();
});

QUnit.test('adstart is fired before a preroll', function (assert) {
  var spy = sinon.spy();

  assert.expect(1);

  this.player.on('adstart', spy);
  this.player.trigger('adsready');
  this.player.trigger('play');
  this.player.ads.startLinearAdMode();
  assert.strictEqual(spy.callCount, 1, 'a preroll triggers adstart');
});

QUnit.test('player has the .vjs-has-started class once a preroll begins', function (assert) {
  assert.expect(1);
  this.player.trigger('adsready');

  // This is a bit of a hack in order to not need the test to be async.
  this.player.tech_.trigger('play');
  this.player.ads.startLinearAdMode();
  assert.ok(this.player.hasClass('vjs-has-started'), 'player has .vjs-has-started class');
});

QUnit.test('moves to content-playback after a preroll', function (assert) {
  assert.expect(2);

  this.player.trigger('adsready');
  this.player.trigger('play');
  this.player.ads.startLinearAdMode();
  this.player.ads.endLinearAdMode();
  assert.strictEqual(this.player.ads.state, 'content-resuming', 'the state is content-resuming');

  this.player.trigger('playing');
  assert.strictEqual(this.player.ads.state, 'content-playback', 'the state is content-resuming');
});

QUnit.test('moves to ad-playback if a midroll is requested', function (assert) {
  assert.expect(1);

  this.player.trigger('adsready');
  this.player.trigger('play');
  this.player.trigger('adtimeout');
  this.player.ads.startLinearAdMode();
  assert.strictEqual(this.player.ads.state, 'ad-playback', 'the state is ad-playback');
});

QUnit.test('moves to content-playback if the preroll times out', function (assert) {
  this.player.trigger('adsready');
  this.player.trigger('play');
  this.player.trigger('adtimeout');
  assert.strictEqual(this.player.ads.state, 'content-playback', 'the state is content-playback');
});

QUnit.test('waits for adsready if play is received first', function (assert) {
  assert.expect(1);

  this.player.trigger('play');
  this.player.trigger('adsready');
  assert.strictEqual(this.player.ads.state, 'preroll?', 'the state is preroll?');
});

QUnit.test('moves to content-playback if a plugin does not finish initializing', function (assert) {
  this.player.trigger('play');
  this.player.trigger('adtimeout');
  assert.strictEqual(this.player.ads.state, 'content-playback', 'the state is content-playback');
});

QUnit.test('calls start immediately on play when ads are ready', function (assert) {
  var readyForPrerollSpy = sinon.spy();

  assert.expect(1);

  this.player.on('readyforpreroll', readyForPrerollSpy);
  this.player.trigger('adsready');
  this.player.trigger('loadstart');
  this.player.trigger('play');
  assert.strictEqual(readyForPrerollSpy.callCount, 1, 'readyforpreroll was fired');
});

QUnit.test('adds the ad-mode class when a preroll plays', function (assert) {
  var el;

  assert.expect(1);

  this.player.trigger('adsready');
  this.player.trigger('play');
  this.player.ads.startLinearAdMode();
  el = this.player.el();
  assert.ok(this.player.hasClass('vjs-ad-playing'), 'the ad class should be in "' + el.className + '"');
});

QUnit.test('removes the ad-mode class when a preroll finishes', function (assert) {
  var el;

  this.player.trigger('adsready');
  this.player.trigger('play');
  this.player.ads.startLinearAdMode();
  this.player.ads.endLinearAdMode();
  el = this.player.el();
  assert.notOk(this.player.hasClass('vjs-ad-playing'), 'the ad class should not be in "' + el.className + '"');
  assert.strictEqual(this.player.ads.triggerevent, 'adend', 'triggerevent for content-resuming should have been adend');

  this.player.trigger('playing');
});

QUnit.test('adds a class while waiting for an ad plugin to load', function (assert) {
  var el;

  assert.expect(1);

  this.player.trigger('play');
  el = this.player.el();
  assert.ok(this.player.hasClass('vjs-ad-loading'), 'the ad loading class should be in "' + el.className + '"');
});

QUnit.test('adds a class while waiting for a preroll', function (assert) {
  var el;

  assert.expect(1);

  this.player.trigger('adsready');
  this.player.trigger('play');
  el = this.player.el();
  assert.ok(this.player.hasClass('vjs-ad-loading'), 'the ad loading class should be in "' + el.className + '"');
});

QUnit.test('removes the loading class when the preroll begins', function (assert) {
  var el;

  assert.expect(1);

  this.player.trigger('adsready');
  this.player.trigger('play');
  this.player.ads.startLinearAdMode();
  this.player.trigger('ads-ad-started');
  el = this.player.el();
  assert.notOk(this.player.hasClass('vjs-ad-loading'), 'there should be no ad loading class present in "' + el.className + '"');
});

QUnit.test('removes the loading class when the preroll times out', function (assert) {
  var el;

  this.player.trigger('adsready');
  this.player.trigger('play');
  this.player.trigger('adtimeout');
  this.player.trigger('playing');
  el = this.player.el();
  assert.notOk(this.player.hasClass('vjs-ad-loading'), 'there should be no ad loading class present in "' + el.className + '"');
});

QUnit.test('starts the content video if there is no preroll', function (assert) {
  var spy = sinon.spy(this.player, 'play');

  this.player.trigger('adsready');
  this.player.trigger('play');
  this.clock.tick(1);
  this.player.trigger('adtimeout');
  assert.strictEqual(spy.callCount, 1, 'play is called once');
});

QUnit.test('removes the poster attribute so it does not flash between videos', function (assert) {
  this.video.poster = 'http://www.videojs.com/img/poster.jpg';
  assert.ok(this.video.poster, 'the poster is present initially');

  this.player.trigger('adsready');
  this.player.trigger('play');
  this.player.ads.startLinearAdMode();
  assert.strictEqual(this.video.poster, '', 'poster is removed');
});

QUnit.test('restores the poster attribute after ads have ended', function (assert) {
  this.video.poster = 'http://www.videojs.com/img/poster.jpg';
  this.player.trigger('adsready');
  this.player.trigger('play');
  this.player.ads.startLinearAdMode();
  this.player.ads.endLinearAdMode();
  assert.ok(this.video.poster, 'the poster is restored');

  this.player.trigger('playing');
});

QUnit.test('changing the src triggers "contentupdate"', function (assert) {
  var spy = sinon.spy();

  assert.expect(1);

  this.player.on('contentupdate', spy);

  // set src and trigger synthetic 'loadstart'
  this.player.src('http://media.w3.org/2010/05/sintel/trailer.mp4');
  this.player.trigger('loadstart');
  assert.strictEqual(spy.callCount, 1, 'one contentupdate event fired');
});

QUnit.test('"contentupdate" should fire when src is changed in "content-resuming" state after postroll', function (assert) {
  var spy = sinon.spy();

  assert.expect(2);

  this.player.on('contentupdate', spy);
  this.player.trigger('adsready');
  this.player.trigger('play');
  this.player.trigger('adtimeout');
  this.player.trigger('ended');
  this.player.trigger('adtimeout');
  this.player.ads.snapshot.ended = true;

  // set src and trigger synthetic 'loadstart'
  this.player.src('http://media.w3.org/2010/05/sintel/trailer.mp4');
  this.player.trigger('loadstart');
  assert.strictEqual(spy.callCount, 1, 'one contentupdate event fired');
  assert.strictEqual(this.player.ads.state, 'content-set', 'we are in the content-set state');
});

QUnit.test('"contentupdate" should fire when src is changed in "content-playback" state after postroll', function (assert) {
  var spy = sinon.spy();

  assert.expect(2);

  this.player.on('contentupdate', spy);
  this.player.trigger('adsready');
  this.player.trigger('play');
  this.player.trigger('adtimeout');
  this.player.trigger('ended');
  this.player.trigger('adtimeout');
  this.player.ads.snapshot.ended = true;
  this.player.trigger('ended');

  // set src and trigger synthetic 'loadstart'
  this.player.src('http://media.w3.org/2010/05/sintel/trailer.mp4');
  this.player.trigger('loadstart');
  assert.strictEqual(spy.callCount, 1, 'one contentupdate event fired');
  assert.strictEqual(this.player.ads.state, 'content-set', 'we are in the content-set state');
});

QUnit.test('changing src does not trigger "contentupdate" during ad playback', function (assert) {
  var spy = sinon.spy();

  this.player.on('contentupdate', spy);

  // enter ad playback mode
  this.player.trigger('adsready');
  this.player.trigger('play');
  this.player.ads.startLinearAdMode();

  // set src and trigger synthetic 'loadstart'
  this.player.src('http://media.w3.org/2010/05/sintel/trailer.mp4');
  this.player.trigger('loadstart');

  // finish playing ad
  this.player.ads.endLinearAdMode();
  assert.strictEqual(spy.callCount, 0, 'no contentupdate events fired');
});

QUnit.test('the `cancelPlayTimeout` timeout is cleared when exiting "preroll?"', function (assert) {
  var setTimeoutSpy = sinon.spy(window, 'setTimeout');

  assert.expect(5);

  this.player.trigger('adsready');
  this.player.trigger('play');
  assert.strictEqual(this.player.ads.state, 'preroll?', 'the player is waiting for prerolls');
  assert.strictEqual(setTimeoutSpy.callCount, 2, 'two timers were created (`cancelPlayTimeout` and `adTimeoutTimeout`)');
  assert.ok(timerExists(this, 'cancelPlayTimeout'), '`cancelPlayTimeout` exists');
  assert.ok(timerExists(this, 'adTimeoutTimeout'), '`adTimeoutTimeout` exists');

  this.player.trigger('play');
  this.player.trigger('play');
  this.player.trigger('play');
  assert.strictEqual(setTimeoutSpy.callCount, 2, 'no additional timers were created on subsequent "play" events');

  window.setTimeout.restore();
});

QUnit.test('"adscanceled" allows us to transition from "content-set" to "content-playback"', function (assert) {
  assert.strictEqual(this.player.ads.state, 'content-set');

  this.player.trigger('adscanceled');
  assert.strictEqual(this.player.ads.state, 'content-playback');
});

QUnit.test('"adscanceled" allows us to transition from "ads-ready?" to "content-playback"', function (assert) {
  var setTimeoutSpy = sinon.spy(window, 'setTimeout');

  assert.strictEqual(this.player.ads.state, 'content-set');

  this.player.trigger('play');
  assert.strictEqual(this.player.ads.state, 'ads-ready?');
  assert.strictEqual(setTimeoutSpy.callCount, 2, 'two timers were created (`cancelPlayTimeout` and `adTimeoutTimeout`)');
  assert.ok(timerExists(this, 'cancelPlayTimeout'), '`cancelPlayTimeout` exists');
  assert.ok(timerExists(this, 'adTimeoutTimeout'), '`adTimeoutTimeout` exists');

  this.player.trigger('adscanceled');
  assert.strictEqual(this.player.ads.state, 'content-playback');
  assert.notOk(timerExists(this, 'cancelPlayTimeout'), '`cancelPlayTimeout` was canceled');

  window.setTimeout.restore();
});

QUnit.test('content is resumed on contentplayback if a user initiated play event is canceled', function (assert) {
  var playSpy = sinon.spy(this.player, 'play');
  var setTimeoutSpy = sinon.spy(window, 'setTimeout');

  assert.expect(8);

  assert.strictEqual(this.player.ads.state, 'content-set');

  this.player.trigger('play');
  assert.strictEqual(this.player.ads.state, 'ads-ready?');
  assert.strictEqual(setTimeoutSpy.callCount, 2, 'two timers were created (`cancelPlayTimeout` and `adTimeoutTimeout`)');
  assert.ok(timerExists(this, 'cancelPlayTimeout'), '`cancelPlayTimeout` exists');
  assert.ok(timerExists(this, 'adTimeoutTimeout'), '`adTimeoutTimeout` exists');

  this.clock.tick(1);
  this.player.trigger('adserror');
  assert.strictEqual(this.player.ads.state, 'content-playback');
  assert.notOk(timerExists(this, 'cancelPlayTimeout'), '`cancelPlayTimeout` was canceled');
  assert.strictEqual(playSpy.callCount, 1, 'a play event should be triggered once we enter "content-playback" state if on was canceled.');
});

QUnit.test('adserror in content-set transitions to content-playback', function (assert) {
  assert.strictEqual(this.player.ads.state, 'content-set');

  this.player.trigger('adserror');
  assert.strictEqual(this.player.ads.state, 'content-playback');
});

QUnit.test('adskip in content-set transitions to content-playback', function (assert) {
  assert.strictEqual(this.player.ads.state, 'content-set');

  this.player.trigger('adskip');
  assert.strictEqual(this.player.ads.state, 'content-playback');
});

QUnit.test('adserror in ads-ready? transitions to content-playback', function (assert) {
  assert.strictEqual(this.player.ads.state, 'content-set');

  this.player.trigger('play');
  assert.strictEqual(this.player.ads.state, 'ads-ready?');

  this.player.trigger('adserror');
  assert.strictEqual(this.player.ads.state, 'content-playback');
});

QUnit.test('adskip in ads-ready? transitions to content-playback', function (assert) {
  assert.strictEqual(this.player.ads.state, 'content-set');

  this.player.trigger('play');
  assert.strictEqual(this.player.ads.state, 'ads-ready?');

  this.player.trigger('adskip');
  assert.strictEqual(this.player.ads.state, 'content-playback');
});

QUnit.test('adserror in ads-ready transitions to content-playback', function (assert) {

  assert.strictEqual(this.player.ads.state, 'content-set');

  this.player.trigger('adsready');
  assert.strictEqual(this.player.ads.state, 'ads-ready');

  this.player.trigger('adserror');
  assert.strictEqual(this.player.ads.state, 'content-playback');
});

QUnit.test('adskip in ads-ready transitions to content-playback', function (assert) {
  assert.strictEqual(this.player.ads.state, 'content-set');

  this.player.trigger('adsready');
  assert.strictEqual(this.player.ads.state, 'ads-ready');

  this.player.trigger('adskip');
  assert.strictEqual(this.player.ads.state, 'content-playback');
});

QUnit.test('adserror in preroll? transitions to content-playback', function (assert) {
  assert.strictEqual(this.player.ads.state, 'content-set');

  this.player.trigger('adsready');
  assert.strictEqual(this.player.ads.state, 'ads-ready');

  this.player.trigger('play');
  assert.strictEqual(this.player.ads.state, 'preroll?');

  this.player.trigger('adserror');
  assert.strictEqual(this.player.ads.state, 'content-playback');
});

QUnit.test('adskip in preroll? transitions to content-playback', function (assert) {
  assert.strictEqual(this.player.ads.state, 'content-set');

  this.player.trigger('adsready');
  assert.strictEqual(this.player.ads.state, 'ads-ready');

  this.player.trigger('play');
  assert.strictEqual(this.player.ads.state, 'preroll?');

  this.player.trigger('adskip');
  assert.strictEqual(this.player.ads.state, 'content-playback');
});

QUnit.test('adserror in postroll? transitions to content-playback and fires ended', function (assert) {
  assert.strictEqual(this.player.ads.state, 'content-set');

  this.player.trigger('adsready');
  assert.strictEqual(this.player.ads.state, 'ads-ready');

  this.player.trigger('play');
  this.player.trigger('adtimeout');
  this.player.trigger('ended');
  assert.strictEqual(this.player.ads.state, 'postroll?');

  this.player.ads.snapshot.ended = true;
  this.player.trigger('adserror');
  assert.strictEqual(this.player.ads.state, 'content-resuming');
  assert.strictEqual(this.player.ads.triggerevent, 'adserror', 'adserror should be the trigger event');

  this.clock.tick(1);
  assert.strictEqual(this.player.ads.state, 'content-playback');
});

QUnit.test('adtimeout in postroll? transitions to content-playback and fires ended', function (assert) {

  assert.strictEqual(this.player.ads.state, 'content-set');

  this.player.trigger('adsready');
  assert.strictEqual(this.player.ads.state, 'ads-ready');

  this.player.trigger('play');
  this.player.trigger('adtimeout');
  this.player.trigger('ended');
  assert.strictEqual(this.player.ads.state, 'postroll?');

  this.player.ads.snapshot.ended = true;
  this.player.trigger('adtimeout');
  assert.strictEqual(this.player.ads.state, 'content-resuming');
  assert.strictEqual(this.player.ads.triggerevent, 'adtimeout', 'adtimeout should be the trigger event');

  this.clock.tick(1);
  assert.strictEqual(this.player.ads.state, 'content-playback');
});

QUnit.test('adskip in postroll? transitions to content-playback and fires ended', function (assert) {

  assert.strictEqual(this.player.ads.state, 'content-set');

  this.player.trigger('adsready');
  assert.strictEqual(this.player.ads.state, 'ads-ready');

  this.player.trigger('play');
  this.player.trigger('adtimeout');
  this.player.trigger('ended');
  assert.strictEqual(this.player.ads.state, 'postroll?');

  this.player.ads.snapshot.ended = true;
  this.player.trigger('adskip');
  assert.strictEqual(this.player.ads.state, 'content-resuming');
  assert.strictEqual(this.player.ads.triggerevent, 'adskip', 'adskip should be the trigger event');

  this.clock.tick(1);
  assert.strictEqual(this.player.ads.state, 'content-playback');
});

QUnit.test('an "ended" event is fired in "content-resuming" via a timeout if not fired naturally', function (assert) {
  var endedSpy = sinon.spy();

  assert.expect(6);

  this.player.on('ended', endedSpy);
  assert.strictEqual(this.player.ads.state, 'content-set');

  this.player.trigger('adsready');
  assert.strictEqual(this.player.ads.state, 'ads-ready');

  this.player.trigger('play');
  this.player.trigger('adtimeout');
  this.player.trigger('ended');
  assert.strictEqual(this.player.ads.state, 'postroll?');

  this.player.ads.startLinearAdMode();
  this.player.ads.snapshot.ended = true;
  this.player.ads.endLinearAdMode();
  assert.strictEqual(this.player.ads.state, 'content-resuming');
  assert.strictEqual(endedSpy.callCount, 0, 'we should not have gotten an ended event yet');

  this.clock.tick(1000);
  assert.strictEqual(endedSpy.callCount, 1, 'we should have fired ended from the timeout');
});

QUnit.test('an "ended" event is not fired in "content-resuming" via a timeout if fired naturally', function (assert) {
  var endedSpy = sinon.spy();

  assert.expect(6);

  this.player.on('ended', endedSpy);
  assert.strictEqual(this.player.ads.state, 'content-set');

  this.player.trigger('adsready');
  assert.strictEqual(this.player.ads.state, 'ads-ready');

  this.player.trigger('play');
  this.player.trigger('adtimeout');
  this.player.trigger('ended');
  assert.strictEqual(this.player.ads.state, 'postroll?');

  this.player.ads.startLinearAdMode();
  this.player.ads.snapshot.ended = true;
  this.player.ads.endLinearAdMode();
  assert.strictEqual(this.player.ads.state, 'content-resuming');
  assert.strictEqual(endedSpy.callCount, 0, 'we should not have gotten an ended event yet');

  this.player.trigger('ended');
  assert.strictEqual(endedSpy.callCount, 1, 'we should have fired ended from the timeout');
});

QUnit.test('adserror in ad-playback transitions to content-playback and triggers adend', function (assert) {
  var spy;

  assert.strictEqual(this.player.ads.state, 'content-set');

  this.player.trigger('adsready');

  assert.strictEqual(this.player.ads.state, 'ads-ready');

  this.player.trigger('play');
  this.player.ads.startLinearAdMode();
  spy = sinon.spy();
  this.player.on('adend', spy);
  this.player.trigger('adserror');
  assert.strictEqual(this.player.ads.state, 'content-resuming');
  assert.strictEqual(this.player.ads.triggerevent, 'adserror', 'The reason for content-resuming should have been adserror');

  this.player.trigger('playing');
  assert.strictEqual(this.player.ads.state, 'content-playback');
  assert.strictEqual(spy.getCall(0).args[0].type, 'adend', 'adend should be fired when we enter content-playback from adserror');
});

QUnit.test('calling startLinearAdMode() when already in ad-playback does not trigger adstart', function (assert) {
  var spy = sinon.spy();

  this.player.on('adstart', spy);
  assert.strictEqual(this.player.ads.state, 'content-set');

  // go through preroll flow
  this.player.trigger('adsready');
  assert.strictEqual(this.player.ads.state, 'ads-ready');

  this.player.trigger('play');
  assert.strictEqual(this.player.ads.state, 'preroll?');

  this.player.ads.startLinearAdMode();
  assert.strictEqual(this.player.ads.state, 'ad-playback');
  assert.strictEqual(spy.callCount, 1, 'adstart should have fired');

  // add an extraneous start call
  this.player.ads.startLinearAdMode();
  assert.strictEqual(spy.callCount, 1, 'adstart should not have fired');

  // make sure subsequent adstarts trigger again on exit/re-enter
  this.player.ads.endLinearAdMode();
  this.player.trigger('playing');
  assert.strictEqual(this.player.ads.state, 'content-playback');

  this.player.ads.startLinearAdMode();
  assert.strictEqual(spy.callCount, 2, 'adstart should have fired');
});

QUnit.test('calling endLinearAdMode() in any state but ad-playback does not trigger adend', function (assert) {
  var spy;

  assert.expect(13);

  spy = sinon.spy();
  this.player.on('adend', spy);
  assert.strictEqual(this.player.ads.state, 'content-set');

  this.player.ads.endLinearAdMode();
  assert.strictEqual(spy.callCount, 0, 'adend should not have fired');

  this.player.trigger('adsready');
  assert.strictEqual(this.player.ads.state, 'ads-ready');

  this.player.ads.endLinearAdMode();
  assert.strictEqual(spy.callCount, 0, 'adend should not have fired');

  this.player.trigger('play');
  assert.strictEqual(this.player.ads.state, 'preroll?');

  this.player.ads.endLinearAdMode();
  assert.strictEqual(spy.callCount, 0, 'adend should not have fired');

  this.player.trigger('adtimeout');
  assert.strictEqual(this.player.ads.state, 'content-playback');

  this.player.ads.endLinearAdMode();
  assert.strictEqual(spy.callCount, 0, 'adend should not have fired');

  this.player.ads.startLinearAdMode();
  assert.strictEqual(this.player.ads.state, 'ad-playback');

  this.player.ads.endLinearAdMode();
  assert.strictEqual(spy.callCount, 1, 'adend should have fired');

  this.player.trigger('playing');
  assert.strictEqual(this.player.ads.state, 'content-playback');

  this.player.ads.startLinearAdMode();
  assert.strictEqual(this.player.ads.state, 'ad-playback');

  this.player.trigger('adserror');
  assert.strictEqual(spy.callCount, 2, 'adend should have fired');
});

QUnit.test('skipLinearAdMode in ad-playback does not trigger adskip', function (assert) {
  var spy;

  spy = sinon.spy();
  this.player.on('adskip', spy);
  assert.strictEqual(this.player.ads.state, 'content-set');

  this.player.trigger('adsready');
  assert.strictEqual(this.player.ads.state, 'ads-ready');

  this.player.trigger('play');
  this.player.ads.startLinearAdMode();
  assert.strictEqual(this.player.ads.state, 'ad-playback');

  this.player.ads.skipLinearAdMode();
  assert.strictEqual(this.player.ads.state, 'ad-playback');
  assert.strictEqual(spy.callCount, 0, 'adskip event should not trigger when skipLinearAdMode called in ad-playback state');

  this.player.ads.endLinearAdMode();
  assert.strictEqual(this.player.ads.state, 'content-resuming');
  assert.strictEqual(this.player.ads.triggerevent, 'adend', 'The reason for content-resuming should have been adend');

  this.player.trigger('playing');
  assert.strictEqual(this.player.ads.state, 'content-playback');
});

QUnit.test('adsready in content-playback triggers readyforpreroll', function (assert) {
  var spy;

  spy = sinon.spy();
  this.player.on('readyforpreroll', spy);
  assert.strictEqual(this.player.ads.state, 'content-set');

  this.player.trigger('play');
  assert.strictEqual(this.player.ads.state, 'ads-ready?');

  this.player.trigger('adtimeout');
  assert.strictEqual(this.player.ads.state, 'content-playback');

  this.player.trigger('adsready');
  assert.strictEqual(spy.getCall(0).args[0].type, 'readyforpreroll', 'readyforpreroll should have been triggered.');
});

// ----------------------------------
// Event prefixing during ad playback
// ----------------------------------

QUnit.test('player events during prerolls are prefixed if tech is reused for ad', function (assert) {
  var prefixed, unprefixed;

  assert.expect(2);

  prefixed = sinon.spy();
  unprefixed = sinon.spy();

  // play a preroll
  this.player.on('readyforpreroll', function () {
    this.ads.startLinearAdMode();
  });

  this.player.trigger('play');
  this.player.trigger('loadstart');
  this.player.trigger('adsready');

  this.player.ads.snapshot = {
    currentSrc: 'something'
  };

  // simulate video events that should be prefixed
  this.player.on(['loadstart', 'playing', 'pause', 'ended', 'firstplay', 'loadedalldata'], unprefixed);
  this.player.on(['adloadstart', 'adpause', 'adended', 'adfirstplay', 'adloadedalldata'], prefixed);
  this.player.trigger('firstplay');
  this.player.trigger('loadstart');
  this.player.trigger('playing');
  this.player.trigger('loadedalldata');
  this.player.trigger('pause');
  this.player.trigger('ended');
  assert.strictEqual(unprefixed.callCount, 0, 'no unprefixed events fired');
  assert.strictEqual(prefixed.callCount, 5, 'prefixed events fired');
});

QUnit.test('player events during midrolls are prefixed if tech is reused for ad', function (assert) {
  var prefixed, unprefixed;

  assert.expect(2);

  prefixed = sinon.spy();
  unprefixed = sinon.spy();

  // play a midroll
  this.player.trigger('play');
  this.player.trigger('loadstart');
  this.player.trigger('adsready');
  this.player.trigger('adtimeout');
  this.player.ads.startLinearAdMode();

  this.player.ads.snapshot = {
    currentSrc: 'something'
  };

  // simulate video events that should be prefixed
  this.player.on(['loadstart', 'playing', 'pause', 'ended', 'firstplay', 'loadedalldata'], unprefixed);
  this.player.on(['adloadstart', 'adpause', 'adended', 'adfirstplay', 'adloadedalldata'], prefixed);
  this.player.trigger('firstplay');
  this.player.trigger('loadstart');
  this.player.trigger('playing');
  this.player.trigger('loadedalldata');
  this.player.trigger('pause');
  this.player.trigger('ended');
  assert.strictEqual(unprefixed.callCount, 0, 'no unprefixed events fired');
  assert.strictEqual(prefixed.callCount, 5, 'prefixed events fired');
});

QUnit.test('player events during postrolls are prefixed if tech is reused for ad', function (assert) {
  var prefixed, unprefixed;

  assert.expect(2);

  prefixed = sinon.spy();
  unprefixed = sinon.spy();

  // play a postroll
  this.player.trigger('play');
  this.player.trigger('loadstart');
  this.player.trigger('adsready');
  this.player.trigger('adtimeout');
  this.player.trigger('ended');
  this.player.ads.startLinearAdMode();

  this.player.ads.snapshot = {
    currentSrc: 'something'
  };

  // simulate video events that should be prefixed
  this.player.on(['loadstart', 'playing', 'pause', 'ended', 'firstplay', 'loadedalldata'], unprefixed);
  this.player.on(['adloadstart', 'adpause', 'adended', 'adfirstplay', 'adloadedalldata'], prefixed);
  this.player.trigger('firstplay');
  this.player.trigger('loadstart');
  this.player.trigger('playing');
  this.player.trigger('loadedalldata');
  this.player.trigger('pause');
  this.player.trigger('ended');
  assert.strictEqual(unprefixed.callCount, 0, 'no unprefixed events fired');
  assert.strictEqual(prefixed.callCount, 5, 'prefixed events fired');
});

QUnit.test('player events during stitched ads are prefixed', function (assert) {
  var prefixed, unprefixed;

  assert.expect(2);

  prefixed = sinon.spy();
  unprefixed = sinon.spy();

  this.player.ads.stitchedAds(true);

  // play a midroll
  this.player.trigger('play');
  this.player.trigger('loadstart');
  this.player.trigger('adsready');
  this.player.trigger('adtimeout');
  this.player.ads.startLinearAdMode();

  // simulate video events that should be prefixed
  this.player.on(['loadstart', 'playing', 'pause', 'ended', 'firstplay', 'loadedalldata'], unprefixed);
  this.player.on(['adloadstart', 'adplaying', 'adpause', 'adended', 'adfirstplay', 'adloadedalldata'], prefixed);
  this.player.trigger('firstplay');
  this.player.trigger('loadstart');
  this.player.trigger('playing');
  this.player.trigger('loadedalldata');
  this.player.trigger('pause');
  this.player.trigger('ended');
  assert.strictEqual(unprefixed.callCount, 0, 'no unprefixed events fired');
  assert.strictEqual(prefixed.callCount, 6, 'prefixed events fired');
});

QUnit.test('player events during content playback are not prefixed', function (assert) {
  var prefixed, unprefixed;

  assert.expect(3);

  prefixed = sinon.spy();
  unprefixed = sinon.spy();

  // play content
  this.player.trigger('play');
  this.player.trigger('adsready');
  this.player.trigger('adtimeout');
  this.player.trigger('playing');
  this.player.trigger('loadedalldata');

  // simulate video events that should not be prefixed
  this.player.on(['seeked', 'playing', 'pause', 'ended', 'firstplay', 'loadedalldata'], unprefixed);
  this.player.on(['adseeked', 'adplaying', 'adpause', 'adended', 'contentended', 'adfirstplay', 'adloadedalldata'], prefixed);
  this.player.trigger('firstplay');
  this.player.trigger('seeked');
  this.player.trigger('playing');
  this.player.trigger('loadedalldata');
  this.player.trigger('pause');
  this.player.trigger('ended');
  assert.strictEqual(unprefixed.callCount, 5, 'unprefixed events fired');
  assert.strictEqual(prefixed.callCount, 1, 'prefixed events fired');
  assert.strictEqual(prefixed.getCall(0).args[0].type, 'contentended', 'prefixed the ended event');
});

QUnit.test('startLinearAdMode should only trigger adstart from correct states', function (assert) {

  var adstart = sinon.spy();
  this.player.on('adstart', adstart);

  this.player.ads.state = 'preroll?';
  this.player.ads.startLinearAdMode();
  assert.strictEqual(adstart.callCount, 1, 'preroll? state');

  this.player.ads.state = 'content-playback';
  this.player.ads.startLinearAdMode();
  assert.strictEqual(adstart.callCount, 2, 'content-playback state');

  this.player.ads.state = 'postroll?';
  this.player.ads.startLinearAdMode();
  assert.strictEqual(adstart.callCount, 3, 'postroll? state');

  this.player.ads.state = 'content-set';
  this.player.ads.startLinearAdMode();
  this.player.ads.state = 'ads-ready?';
  this.player.ads.startLinearAdMode();
  this.player.ads.state = 'ads-ready';
  this.player.ads.startLinearAdMode();
  this.player.ads.state = 'ad-playback';
  this.player.ads.startLinearAdMode();
  assert.strictEqual(adstart.callCount, 3, 'other states');
});

QUnit.test('ad impl can notify contrib-ads there is no preroll', function (assert) {

  this.player.ads.state = 'preroll?';
  this.player.trigger('nopreroll');
  assert.strictEqual(this.player.ads.state, 'content-playback', 'no longer in preroll?');
});

QUnit.test('ad impl can notify contrib-ads there is no postroll', function (assert) {

  this.player.trigger('nopostroll');
  this.player.ads.state = 'content-playback';
  this.player.trigger('contentended');
  this.clock.tick(5);
  assert.strictEqual(this.player.ads.state, 'content-playback', 'no longer in postroll?');
});

QUnit.test('ended event is sent with postroll', function (assert) {

  var ended = sinon.spy();

  this.player.tech_.el_ = {
    ended: true,
    hasChildNodes: function hasChildNodes() {
      return false;
    },
    removeAttribute: function removeAttribute() {}
  };
  this.player.on('ended', ended);
  this.player.ads.state = 'content-playback';
  this.player.trigger('contentended');

  this.clock.tick(10000);

  assert.ok(ended.calledOnce, 'Ended triggered');
});

QUnit.test('ended event is sent without postroll', function (assert) {

  var ended = sinon.spy();

  this.player.tech_.el_ = {
    ended: true,
    hasChildNodes: function hasChildNodes() {
      return false;
    },
    removeAttribute: function removeAttribute() {}
  };
  this.player.on('ended', ended);
  this.player.ads.state = 'content-playback';
  this.player.trigger('contentended');

  this.clock.tick(10000);
  assert.ok(ended.calledOnce, 'Ended triggered');
});

QUnit.test('isLive', function (assert) {

  // Make videojs.browser writeable
  videojs.browser = _extends({}, videojs.browser);

  this.player.duration = function () {
    return 0;
  };
  videojs.browser.IOS_VERSION = '8';
  assert.strictEqual(this.player.ads.isLive(this.player), true);

  this.player.duration = function () {
    return 5;
  };
  videojs.browser.IOS_VERSION = '8';
  assert.strictEqual(this.player.ads.isLive(this.player), false);

  this.player.duration = function () {
    return Infinity;
  };
  videojs.browser.IOS_VERSION = '8';
  assert.strictEqual(this.player.ads.isLive(this.player), true);

  this.player.duration = function () {
    return 0;
  };
  videojs.browser.IOS_VERSION = undefined;
  assert.strictEqual(this.player.ads.isLive(this.player), false);

  this.player.duration = function () {
    return 5;
  };
  videojs.browser.IOS_VERSION = undefined;
  assert.strictEqual(this.player.ads.isLive(this.player), false);

  this.player.duration = function () {
    return Infinity;
  };
  videojs.browser.IOS_VERSION = undefined;
  assert.strictEqual(this.player.ads.isLive(this.player), true);
});

QUnit.test('shouldPlayContentBehindAd', function (assert) {

  // Make videojs.browser writeable
  videojs.browser = _extends({}, videojs.browser);

  this.player.duration = function () {
    return Infinity;
  };
  videojs.browser.IS_IOS = true;
  videojs.browser.IS_ANDROID = true;
  assert.strictEqual(this.player.ads.shouldPlayContentBehindAd(this.player), false);

  this.player.duration = function () {
    return Infinity;
  };
  videojs.browser.IS_IOS = true;
  videojs.browser.IS_ANDROID = false;
  assert.strictEqual(this.player.ads.shouldPlayContentBehindAd(this.player), false);

  this.player.duration = function () {
    return Infinity;
  };
  videojs.browser.IS_IOS = false;
  videojs.browser.IS_ANDROID = true;
  assert.strictEqual(this.player.ads.shouldPlayContentBehindAd(this.player), false);

  this.player.duration = function () {
    return Infinity;
  };
  videojs.browser.IS_IOS = false;
  videojs.browser.IS_ANDROID = false;
  assert.strictEqual(this.player.ads.shouldPlayContentBehindAd(this.player), true);

  this.player.duration = function () {
    return 5;
  };
  videojs.browser.IS_IOS = true;
  videojs.browser.IS_ANDROID = true;
  assert.strictEqual(this.player.ads.shouldPlayContentBehindAd(this.player), false);

  this.player.duration = function () {
    return 5;
  };
  videojs.browser.IS_IOS = true;
  videojs.browser.IS_ANDROID = false;
  assert.strictEqual(this.player.ads.shouldPlayContentBehindAd(this.player), false);

  this.player.duration = function () {
    return 5;
  };
  videojs.browser.IS_IOS = false;
  videojs.browser.IS_ANDROID = true;
  assert.strictEqual(this.player.ads.shouldPlayContentBehindAd(this.player), false);

  this.player.duration = function () {
    return 5;
  };
  videojs.browser.IS_IOS = false;
  videojs.browser.IS_ANDROID = false;
  assert.strictEqual(this.player.ads.shouldPlayContentBehindAd(this.player), false);
});

QUnit.test('Check incorrect addition of vjs-live during ad-playback', function (assert) {
  this.player.trigger('play');
  this.player.ads.startLinearAdMode();
  assert.strictEqual(this.player.hasClass('vjs-live'), false, 'We have the correct class');
});

QUnit.test('Check for existence of vjs-live after ad-end for LIVE videos', function (assert) {
  this.player.trigger('adstart');
  this.player.ads.startLinearAdMode();
  this.player.ads.state = 'ad-playback';
  this.player.duration = function () {
    return Infinity;
  };
  this.player.ads.endLinearAdMode();
  this.player.trigger('playing');
  assert.strictEqual(this.player.ads.isLive(this.player), true, 'Content is LIVE');
  assert.ok(this.player.hasClass('vjs-live'), 'We should be having vjs-live class here');
});

QUnit.test('Plugin state resets after contentupdate', function (assert) {

  assert.equal(this.player.ads.disableNextSnapshotRestore, false);
  assert.equal(this.player.ads._contentHasEnded, false);
  assert.equal(this.player.ads.snapshot, null);

  this.player.ads.disableNextSnapshotRestore = true;
  this.player.ads._contentHasEnded = true;
  this.player.ads.snapshot = {};

  this.player.trigger('contentupdate');

  assert.equal(this.player.ads.disableNextSnapshotRestore, false);
  assert.equal(this.player.ads._contentHasEnded, false);
  assert.equal(this.player.ads.snapshot, null);
});

QUnit.test('Plugin sets adType as expected', function (assert) {

  // adType is unset originally
  assert.strictEqual(this.player.ads.adType, null);

  // begins in content-set, preroll happens, adType is preroll
  this.player.ads.state = 'content-set';
  this.player.trigger('adsready');
  assert.strictEqual(this.player.ads.state, 'ads-ready');
  assert.strictEqual(this.player.ads.adType, null);
  this.player.trigger('play');
  this.clock.tick(1);
  assert.strictEqual(this.player.ads.state, 'preroll?');
  assert.strictEqual(this.player.ads.adType, null);

  // ad starts and finishes
  this.player.trigger('adstart');
  assert.strictEqual(this.player.ads.adType, 'preroll');
  this.player.trigger('adend');
  this.clock.tick(1);
  assert.strictEqual(this.player.ads.adType, null);

  // content is playing, midroll starts
  this.player.trigger('playing');
  this.clock.tick(1);
  this.player.trigger('adstart');
  assert.strictEqual(this.player.ads.adType, 'midroll');

  // midroll ends, content is playing
  this.player.trigger('adend');
  this.clock.tick(1);
  assert.strictEqual(this.player.ads.adType, null);
  this.player.trigger('playing');
  this.clock.tick(1);

  // postroll starts
  this.player.trigger('contentended');
  this.clock.tick(1);
  this.player.trigger('adstart');
  assert.strictEqual(this.player.ads.adType, 'postroll');

  // postroll ends
  this.player.trigger('adend');
  this.clock.tick(1);
  assert.strictEqual(this.player.ads.adType, null);
  this.clock.tick(1);

  // reset values
  this.player.trigger('contentupdate');
  assert.strictEqual(this.player.ads.state, 'content-set');
  assert.strictEqual(this.player.ads.adType, null);

  // check preroll case where play is observed
  this.player.trigger('play');
  assert.strictEqual(this.player.ads.state, 'ads-ready?');
  assert.strictEqual(this.player.ads.adType, null);
  this.player.trigger('adsready');
  assert.strictEqual(this.player.ads.state, 'preroll?');
  assert.strictEqual(this.player.ads.adType, null);
  this.player.trigger('adstart');
  assert.strictEqual(this.player.ads.adType, 'preroll');
});

QUnit.test('adserror ends linear ad mode ', function (assert) {
  assert.strictEqual(this.player.ads._inLinearAdMode, false, 'before ad');
  this.player.trigger('play');
  this.player.trigger('adsready');
  this.player.ads.startLinearAdMode();
  assert.strictEqual(this.player.ads._inLinearAdMode, true, 'during ad');
  this.player.trigger('adserror');
  assert.strictEqual(this.player.ads._inLinearAdMode, false, 'after adserror');
});

},{}],6:[function(require,module,exports){
'use strict';

QUnit.module('Cue Metadata Text Tracks', window.sharedModuleHooks({

  beforeEach: function beforeEach() {
    this.tt = {
      player: this.player,
      kind: 'metadata',
      mode: 'hidden',
      id: '1',
      startTime: 1,
      endTime: 2,
      addEventListener: function addEventListener(event, cb) {
        if (event === 'cuechange') {
          cb.apply(this, [this]);
        }
      },
      activeCues: []
    };
  },
  afterEach: function afterEach() {
    this.player.ads.cueTextTracks.getSupportedAdCue = function (player, cue) {
      return cue;
    };
    this.player.ads.cueTextTracks.getCueId = function (cue) {
      return cue.id;
    };
    this.player.ads.cueTextTracks.setMetadataTrackMode = function (track) {
      track.mode = 'hidden';
    };
  }
}));

QUnit.test('runs processMetadataTrack callback as tracks are added', function (assert) {
  var tt = this.tt;
  var processMetadataTrackSpy = sinon.spy();
  var cueTextTracks = this.player.ads.cueTextTracks;

  // Start by adding a text track before processing
  this.player.addRemoteTextTrack(tt);

  cueTextTracks.processMetadataTracks(this.player, processMetadataTrackSpy);
  assert.strictEqual(processMetadataTrackSpy.callCount, 1);

  // add a new text track after initial processing
  this.player.textTracks().trigger({
    track: this.tt,
    type: 'addtrack'
  });
  assert.strictEqual(processMetadataTrackSpy.callCount, 2);
});

QUnit.test('does not call processMetadataTrack callback until tracks available', function (assert) {
  var processMetadataTrackSpy = sinon.spy();
  var cueTextTracks = this.player.ads.cueTextTracks;

  cueTextTracks.processMetadataTracks(this.player, processMetadataTrackSpy);
  assert.strictEqual(processMetadataTrackSpy.callCount, 0);

  var addTrackEvent = {
    track: this.tt,
    type: 'addtrack'
  };
  this.player.textTracks().trigger(addTrackEvent);
  assert.strictEqual(processMetadataTrackSpy.callCount, 1);
});

QUnit.test('setMetadataTrackMode should work when overriden', function (assert) {
  var tt = this.tt;
  var cueTextTracks = this.player.ads.cueTextTracks;

  cueTextTracks.setMetadataTrackMode(tt);
  assert.strictEqual(tt.mode, 'hidden');

  cueTextTracks.setMetadataTrackMode = function (track) {
    track.mode = 'disabled';
  };
  cueTextTracks.setMetadataTrackMode(tt);
  assert.strictEqual(tt.mode, 'disabled');
});

QUnit.test('getSupportedAdCue should work when overriden', function (assert) {
  var cue = {
    startTime: 0,
    endTime: 1
  };

  var cueTextTracks = this.player.ads.cueTextTracks;
  var supportedCue = cueTextTracks.getSupportedAdCue(this.player, cue);
  assert.strictEqual(supportedCue, cue);

  cueTextTracks.getSupportedAdCue = function (player, cue) {
    return -1;
  };
  supportedCue = cueTextTracks.getSupportedAdCue(this.player, cue);
  assert.strictEqual(supportedCue, -1);
});

QUnit.test('getCueId should work when overriden', function (assert) {
  var cue = {
    startTime: 0,
    endTime: 1,
    id: 1,
    inner: {
      id: 2
    }
  };
  var tt = this.tt;
  tt.activeCues = [cue];

  this.player.textTracks = function () {
    return {
      length: 1,
      0: tt
    };
  };

  var cueTextTracks = this.player.ads.cueTextTracks;
  var cueId = cueTextTracks.getCueId(cue);
  assert.strictEqual(cueId, 1);

  cueTextTracks.getCueId = function (cue) {
    return cue.inner.id;
  };
  cueId = cueTextTracks.getCueId(cue);
  assert.strictEqual(cueId, 2);
});

QUnit.test('processAdTrack runs processCue callback', function (assert) {
  var processCueSpy = sinon.spy();
  var cueTextTracks = this.player.ads.cueTextTracks;
  var cues = [{
    startTime: 0,
    endTime: 1,
    id: 1,
    callCount: 0
  }];

  cueTextTracks.processAdTrack(this.player, cues, processCueSpy);
  assert.strictEqual(processCueSpy.callCount, 1);

  var processCue = function processCue(player, cueData, cueId, startTime) {
    cueData.callCount += 1;
  };
  cueTextTracks.processAdTrack(this.player, cues, processCue);
  assert.strictEqual(cues[0].callCount, 1);
});

QUnit.test('processAdTrack runs cancelAds callback', function (assert) {
  var cancelAdsSpy = sinon.spy();
  var cueTextTracks = this.player.ads.cueTextTracks;
  var cues = [{
    startTime: 0,
    endTime: 1,
    id: 1,
    callCount: 0
  }];
  var processCue = function processCue(player, cueData, cueId, startTime) {
    return;
  };
  var cancelAds = function cancelAds(player, cueData, cueId, startTime) {
    cueData.callCount += 1;
  };

  cueTextTracks.processAdTrack(this.player, cues, processCue, cancelAdsSpy);
  assert.strictEqual(cancelAdsSpy.callCount, 1);

  cueTextTracks.processAdTrack(this.player, cues, processCue, cancelAds);
  assert.strictEqual(cues[0].callCount, 1);
});

},{}],7:[function(require,module,exports){
(function (global){
'use strict';

var _qunit = (typeof window !== "undefined" ? window['QUnit'] : typeof global !== "undefined" ? global['QUnit'] : null);

var _qunit2 = _interopRequireDefault(_qunit);

var _video = (typeof window !== "undefined" ? window['videojs'] : typeof global !== "undefined" ? global['videojs'] : null);

var _video2 = _interopRequireDefault(_video);

require('../example/example-integration.js');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

_qunit2['default'].module('Events and Midrolls', {
  beforeEach: function beforeEach() {
    this.video = document.createElement('video');

    this.fixture = document.createElement('div');
    document.querySelector('body').appendChild(this.fixture);
    this.fixture.appendChild(this.video);

    this.player = (0, _video2['default'])(this.video);

    this.player.src({
      src: 'http://vjs.zencdn.net/v/oceans.webm',
      type: 'video/webm'
    });

    this.player.exampleAds({
      'adServerUrl': '/base/test/inventory.json',
      'playPreroll': false,
      'midrollPoint': 1
    });
  },

  afterEach: function afterEach() {
    this.player.dispose();
    this.fixture.parentNode.removeChild(this.fixture);
  }
}); /*
    TODO:
    * timeupdate, adtimeupdate, contenttimeupdate
    * loadstart, adloadstart, contentloadstart
    * play, adplay, contentplay
    * loadeddata, adloadeddata, contentloadeddata
    * loadedmetadata, adloadedmetadata, contentloadedmetadata
    */

_qunit2['default'].test('Midrolls', function (assert) {
  var _this = this;

  var done = assert.async();

  var beforeMidroll = true;
  var seenInAdMode = [];
  var seenInContentResuming = [];
  var seenOutsideAdModeBefore = [];
  var seenOutsideAdModeAfter = [];

  this.player.on('adend', function () {
    beforeMidroll = false;
  });

  var events = ['suspend', 'abort', 'error', 'emptied', 'stalled', 'canplay', 'canplaythrough', 'waiting', 'seeking', 'durationchange', 'progress', 'pause', 'ratechange', 'volumechange', 'firstplay', 'suspend', 'playing', 'ended'];

  events = events.concat(events.map(function (e) {
    return 'ad' + e;
  }));

  events = events.concat(events.map(function (e) {
    return 'content' + e;
  }));

  this.player.on(events, function (e) {
    var str = e.type;
    if (_this.player.ads.isInAdMode()) {
      if (_this.player.ads.isContentResuming()) {
        seenInContentResuming.push(str);
      } else {
        seenInAdMode.push(str);
      }
    } else {
      if (beforeMidroll) {
        seenOutsideAdModeBefore.push(str);
      } else {
        seenOutsideAdModeAfter.push(str);
      }
    }
  });

  this.player.on(['error', 'aderror'], function () {
    assert.ok(false, 'no errors');
    done();
  });

  this.player.on('timeupdate', function () {
    if (_this.player.currentTime() > 2) {

      seenOutsideAdModeBefore.forEach(function (event) {
        assert.ok(!/^ad/.test(event), event + ' has no ad prefix before midroll');
        assert.ok(!/^content/.test(event), event + ' has no content prefix before midroll');
      });

      seenInAdMode.forEach(function (event) {
        assert.ok(/^ad/.test(event), event + ' has ad prefix during midroll');
      });

      seenInContentResuming.forEach(function (event) {
        assert.ok(/^content/.test(event), event + ' has content prefix during midroll');
      });

      seenOutsideAdModeAfter.forEach(function (event) {
        assert.ok(!/^ad/.test(event), event + ' has no ad prefix after midroll');
        assert.ok(!/^content/.test(event), event + ' has no content prefix after midroll');
      });

      done();
    }
  });

  this.player.play();
});

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../example/example-integration.js":1}],8:[function(require,module,exports){
(function (global){
'use strict';

var _qunit = (typeof window !== "undefined" ? window['QUnit'] : typeof global !== "undefined" ? global['QUnit'] : null);

var _qunit2 = _interopRequireDefault(_qunit);

var _video = (typeof window !== "undefined" ? window['videojs'] : typeof global !== "undefined" ? global['videojs'] : null);

var _video2 = _interopRequireDefault(_video);

require('../example/example-integration.js');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

_qunit2['default'].module('Final Events With No Postroll', {
  beforeEach: function beforeEach() {
    this.video = document.createElement('video');

    this.fixture = document.createElement('div');
    document.querySelector('body').appendChild(this.fixture);
    this.fixture.appendChild(this.video);

    this.player = (0, _video2['default'])(this.video);

    this.player.src({
      src: 'http://vjs.zencdn.net/v/oceans.webm',
      type: 'video/webm'
    });

    this.player.exampleAds({
      'adServerUrl': '/base/test/inventory.json',
      'playPreroll': false,
      'playMidroll': false,
      'playPostroll': false
    });
  },

  afterEach: function afterEach() {
    this.player.dispose();
    this.fixture.parentNode.removeChild(this.fixture);
  }
});

_qunit2['default'].test('final ended event with no postroll: just 1', function (assert) {
  var _this = this;

  var done = assert.async();

  var endedEvents = 0;

  this.player.on('ended', function () {
    endedEvents++;
  });

  this.player.on(['error', 'aderror'], function () {
    assert.ok(false, 'no errors');
    done();
  });

  this.player.one('ended', function () {
    // Run checks after a pause in case there are multiple ended events.
    setTimeout(function () {
      assert.equal(endedEvents, 1, 'exactly one ended with no postroll');
      done();
    }, 1000);
  });

  // Seek to end once we're ready so postroll can play quickly
  this.player.one('playing', function () {
    _this.player.currentTime(46);
  });

  this.player.play();
});

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../example/example-integration.js":1}],9:[function(require,module,exports){
(function (global){
'use strict';

var _qunit = (typeof window !== "undefined" ? window['QUnit'] : typeof global !== "undefined" ? global['QUnit'] : null);

var _qunit2 = _interopRequireDefault(_qunit);

var _video = (typeof window !== "undefined" ? window['videojs'] : typeof global !== "undefined" ? global['videojs'] : null);

var _video2 = _interopRequireDefault(_video);

require('../example/example-integration.js');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

_qunit2['default'].module('Initial Events With No Preroll', {
  beforeEach: function beforeEach() {
    this.video = document.createElement('video');

    this.fixture = document.createElement('div');
    document.querySelector('body').appendChild(this.fixture);
    this.fixture.appendChild(this.video);

    this.player = (0, _video2['default'])(this.video);

    this.player.src({
      src: 'http://vjs.zencdn.net/v/oceans.webm',
      type: 'video/webm'
    });

    this.player.exampleAds({
      'adServerUrl': '/base/test/inventory.json',
      'playPreroll': false,
      'playMidroll': false
    });
  },

  afterEach: function afterEach() {
    this.player.dispose();
    this.fixture.parentNode.removeChild(this.fixture);
  }
});

_qunit2['default'].test('initial play event with no preroll: one please', function (assert) {
  var _this = this;

  var done = assert.async();

  var playEvents = 0;

  this.player.on('play', function () {
    playEvents++;
  });

  this.player.on(['error', 'aderror'], function () {
    assert.ok(false, 'no errors');
    done();
  });

  this.player.on('timeupdate', function () {
    if (_this.player.currentTime() > 1) {
      assert.equal(playEvents, 1, '1 play event');
      done();
    }
  });

  this.player.play();
});

_qunit2['default'].test('initial playing event with no preroll: 1+', function (assert) {
  var _this2 = this;

  var done = assert.async();

  var playingEvents = 0;

  this.player.on('playing', function () {
    playingEvents++;
  });

  this.player.on(['error', 'aderror'], function () {
    assert.ok(false, 'no errors');
    done();
  });

  this.player.on('timeupdate', function () {
    if (_this2.player.currentTime() > 1) {
      assert.ok(playingEvents >= 1, '1+ playing events');
      done();
    }
  });

  this.player.play();
});

_qunit2['default'].test('no ended event at start if video with no preroll', function (assert) {
  var _this3 = this;

  var done = assert.async();

  var endedEvents = 0;

  this.player.on('ended', function () {
    endedEvents++;
  });

  this.player.on(['error', 'aderror'], function () {
    assert.ok(false, 'no errors');
    done();
  });

  this.player.on('timeupdate', function () {
    if (_this3.player.currentTime() > 1) {
      assert.equal(endedEvents, 0, 'no ended events');
      done();
    }
  });

  this.player.play();
});

_qunit2['default'].test('initial loadstart event with no preroll: one please', function (assert) {
  var _this4 = this;

  var done = assert.async();

  var loadstartEvents = 0;

  this.player.on('loadstart', function () {
    loadstartEvents++;
  });

  this.player.on(['error', 'aderror'], function () {
    assert.ok(false, 'no errors');
    done();
  });

  this.player.on('timeupdate', function () {
    if (_this4.player.currentTime() > 1) {
      assert.equal(loadstartEvents, 1, '1 loadstart event');
      done();
    }
  });

  this.player.play();
});

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../example/example-integration.js":1}],10:[function(require,module,exports){
(function (global){
'use strict';

var _qunit = (typeof window !== "undefined" ? window['QUnit'] : typeof global !== "undefined" ? global['QUnit'] : null);

var _qunit2 = _interopRequireDefault(_qunit);

var _video = (typeof window !== "undefined" ? window['videojs'] : typeof global !== "undefined" ? global['videojs'] : null);

var _video2 = _interopRequireDefault(_video);

require('../example/example-integration.js');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

_qunit2['default'].module('Events and Postrolls', {
  beforeEach: function beforeEach() {
    this.video = document.createElement('video');

    this.fixture = document.createElement('div');
    document.querySelector('body').appendChild(this.fixture);
    this.fixture.appendChild(this.video);

    this.player = (0, _video2['default'])(this.video);

    this.player.src({
      src: 'http://vjs.zencdn.net/v/oceans.webm',
      type: 'video/webm'
    });

    this.player.exampleAds({
      'adServerUrl': '/base/test/inventory.json',
      'playPreroll': false,
      'playMidroll': false
    });
  },

  afterEach: function afterEach() {
    this.player.dispose();
    this.fixture.parentNode.removeChild(this.fixture);
  }
}); /*
    TODO:
    * timeupdate, adtimeupdate, contenttimeupdate
    * loadstart, adloadstart, contentloadstart
    * play, adplay, contentplay
    * contentended
    * loadeddata, adloadeddata, contentloadeddata
    * loadedmetadata, adloadedmetadata, contentloadedmetadata
    */

_qunit2['default'].test('ended event and postrolls: 0 before postroll, 1 after', function (assert) {
  var _this = this;

  var done = assert.async();

  var beforePostroll = true;
  var endedBeforePostroll = 0;
  var endedAfterPostroll = 0;

  this.player.on('adend', function () {
    beforePostroll = false;
  });

  this.player.on('ended', function () {
    if (beforePostroll) {
      endedBeforePostroll++;
    } else {
      endedAfterPostroll++;
    }
  });

  this.player.on(['error', 'aderror'], function () {
    assert.ok(false, 'no errors');
    done();
  });

  this.player.one('ended', function () {
    if (beforePostroll) {
      assert.ok(false, 'ended before postroll!');
    }
    // Run checks after a pause in case there are multiple ended events.
    setTimeout(function () {
      assert.equal(endedBeforePostroll, 0, 'no ended before postroll');
      assert.equal(endedAfterPostroll, 1, 'exactly one ended after postroll');
      done();
    }, 1000);
  });

  // Seek to end once we're ready so postroll can play quickly
  this.player.one('playing', function () {
    _this.player.currentTime(46);
  });

  this.player.play();
});

_qunit2['default'].test('Event prefixing and postrolls', function (assert) {
  var _this2 = this;

  var done = assert.async();

  var beforePostroll = true;
  var seenInAdMode = [];
  var seenInContentResuming = [];
  var seenOutsideAdModeBefore = [];
  var seenOutsideAdModeAfter = [];

  this.player.on('adend', function () {
    beforePostroll = false;
  });

  var events = ['suspend', 'abort', 'error', 'emptied', 'stalled', 'canplay', 'canplaythrough', 'waiting', 'seeking', 'durationchange', 'progress', 'pause', 'ratechange', 'volumechange', 'firstplay', 'suspend', 'playing', 'ended'];

  events = events.concat(events.map(function (e) {
    return 'ad' + e;
  }));

  events = events.concat(events.map(function (e) {
    return 'content' + e;
  }));

  this.player.on(events, function (e) {
    if (e.type === 'contentended') {
      return;
    }
    var str = e.type;
    if (_this2.player.ads.isInAdMode()) {
      if (_this2.player.ads.isContentResuming()) {
        seenInContentResuming.push(str);
      } else {
        seenInAdMode.push(str);
      }
    } else {
      if (beforePostroll) {
        seenOutsideAdModeBefore.push(str);
      } else {
        seenOutsideAdModeAfter.push(str);
      }
    }
  });

  this.player.on(['error', 'aderror'], function () {
    assert.ok(false, 'no errors');
    done();
  });

  this.player.on('ended', function () {

    seenOutsideAdModeBefore.forEach(function (event) {
      assert.ok(!/^ad/.test(event), event + ' has no ad prefix before postroll');
      assert.ok(!/^content/.test(event), event + ' has no content prefix before postroll');
    });

    seenInAdMode.forEach(function (event) {
      assert.ok(/^ad/.test(event), event + ' has ad prefix during postroll');
    });

    seenInContentResuming.forEach(function (event) {
      assert.ok(/^content/.test(event), event + ' has content prefix during postroll');
    });

    seenOutsideAdModeAfter.forEach(function (event) {
      assert.ok(!/^ad/.test(event), event + ' has no ad prefix after postroll');
      assert.ok(!/^content/.test(event), event + ' has no content prefix after postroll');
    });

    done();
  });

  // Seek to end once we're ready so postroll can play quickly
  this.player.one('playing', function () {
    _this2.player.currentTime(46);
  });

  this.player.play();
});

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../example/example-integration.js":1}],11:[function(require,module,exports){
(function (global){
'use strict';

var _qunit = (typeof window !== "undefined" ? window['QUnit'] : typeof global !== "undefined" ? global['QUnit'] : null);

var _qunit2 = _interopRequireDefault(_qunit);

var _video = (typeof window !== "undefined" ? window['videojs'] : typeof global !== "undefined" ? global['videojs'] : null);

var _video2 = _interopRequireDefault(_video);

require('../example/example-integration.js');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

_qunit2['default'].module('Events and Prerolls', {
  beforeEach: function beforeEach() {
    this.video = document.createElement('video');

    this.fixture = document.createElement('div');
    document.querySelector('body').appendChild(this.fixture);
    this.fixture.appendChild(this.video);

    this.player = (0, _video2['default'])(this.video);

    this.player.src({
      src: 'http://vjs.zencdn.net/v/oceans.webm',
      type: 'video/webm'
    });

    this.player.exampleAds({
      'adServerUrl': '/base/test/inventory.json'
    });
  },

  afterEach: function afterEach() {
    this.player.dispose();
    this.fixture.parentNode.removeChild(this.fixture);
  }
}); /*
    TODO:
    * adplay, contentplay
    * adplaying, contentplaying
    * adloadstart, contentloadstart
    * adended, contentended
    * adloadeddata, contentloadeddata
    * adloadedmetadata, contentloadedmetadata
    */

_qunit2['default'].test('playing event and prerolls: 0 before preroll, 1+ after', function (assert) {
  var _this = this;

  var done = assert.async();

  var beforePreroll = true;
  var playingBeforePreroll = 0;
  var playingAfterPreroll = 0;

  this.player.on('adend', function () {
    beforePreroll = false;
  });

  this.player.on('playing', function () {
    if (beforePreroll) {
      playingBeforePreroll++;
    } else {
      playingAfterPreroll++;
    }
  });

  this.player.on(['error', 'aderror'], function () {
    assert.ok(false, 'no errors');
    done();
  });

  this.player.on('timeupdate', function () {
    if (_this.player.currentTime() > 1) {
      assert.equal(playingBeforePreroll, 0, 'no playing before preroll');
      assert.ok(playingAfterPreroll > 0, 'playing after preroll');
      done();
    }
  });

  this.player.play();
});

_qunit2['default'].test('ended event and prerolls: not even once', function (assert) {
  var _this2 = this;

  var done = assert.async();

  var ended = 0;

  this.player.on('ended', function () {
    ended++;
  });

  this.player.on(['error', 'aderror'], function () {
    assert.ok(false, 'no errors');
    done();
  });

  this.player.on('timeupdate', function () {
    if (_this2.player.currentTime() > 1) {
      assert.equal(ended, 0, 'no ended events');
      done();
    }
  });

  this.player.play();
});

_qunit2['default'].test('loadstart event and prerolls: 1 before preroll, 0 after', function (assert) {
  var _this3 = this;

  var done = assert.async();

  var beforePreroll = true;
  var loadstartBeforePreroll = 0;
  var loadstartAfterPreroll = 0;

  this.player.on('adend', function () {
    beforePreroll = false;
  });

  this.player.on('loadstart', function (e) {
    if (beforePreroll) {
      loadstartBeforePreroll++;
    } else {
      loadstartAfterPreroll++;
    }
  });

  this.player.on(['error', 'aderror'], function () {
    assert.ok(false, 'no errors');
    done();
  });

  this.player.on('timeupdate', function (e) {
    if (_this3.player.currentTime() > 1) {
      assert.equal(loadstartBeforePreroll, 1, 'loadstart before preroll');
      assert.equal(loadstartAfterPreroll, 0, 'loadstart after preroll');
      done();
    }
  });

  this.player.play();
});

_qunit2['default'].test('loadedmetadata event and prerolls: 1 before preroll, 0 after', function (assert) {
  var _this4 = this;

  var done = assert.async();

  var beforePreroll = true;
  var loadedmetadataBeforePreroll = 0;
  var loadedmetadataAfterPreroll = 0;

  this.player.on('adend', function () {
    beforePreroll = false;
  });

  this.player.on('loadedmetadata', function (e) {
    if (beforePreroll) {
      loadedmetadataBeforePreroll++;
    } else {
      loadedmetadataAfterPreroll++;
    }
  });

  this.player.on(['error', 'aderror'], function () {
    assert.ok(false, 'no errors');
    done();
  });

  this.player.on('timeupdate', function (e) {
    if (_this4.player.currentTime() > 1) {
      assert.equal(loadedmetadataBeforePreroll, 1, 'loadedmetadata before preroll');
      assert.equal(loadedmetadataAfterPreroll, 0, 'loadedmetadata after preroll');
      done();
    }
  });

  this.player.play();
});

_qunit2['default'].test('loadeddata event and prerolls: 1 before preroll, 0 after', function (assert) {
  var _this5 = this;

  var done = assert.async();

  var beforePreroll = true;
  var loadeddataBeforePreroll = 0;
  var loadeddataAfterPreroll = 0;

  this.player.on('adend', function () {
    beforePreroll = false;
  });

  this.player.on('loadeddata', function (e) {
    if (beforePreroll) {
      loadeddataBeforePreroll++;
    } else {
      loadeddataAfterPreroll++;
    }
  });

  this.player.on(['error', 'aderror'], function () {
    assert.ok(false, 'no errors');
    done();
  });

  this.player.on('timeupdate', function (e) {
    if (_this5.player.currentTime() > 1) {
      assert.equal(loadeddataBeforePreroll, 1, 'loadeddata before preroll');
      assert.equal(loadeddataAfterPreroll, 0, 'loadeddata after preroll');
      done();
    }
  });

  this.player.play();
});

_qunit2['default'].test('play event and prerolls: 1 before preroll, 0 after', function (assert) {
  var _this6 = this;

  var done = assert.async();

  var beforePreroll = true;
  var playBeforePreroll = 0;
  var playAfterPreroll = 0;

  this.player.on('adend', function () {
    beforePreroll = false;
  });

  this.player.on('play', function () {
    if (beforePreroll) {
      playBeforePreroll++;
    } else {
      playAfterPreroll++;
    }
  });

  this.player.on(['error', 'aderror'], function () {
    assert.ok(false, 'no errors');
    done();
  });

  this.player.on('timeupdate', function () {
    if (_this6.player.currentTime() > 1) {
      assert.equal(playBeforePreroll, 1, 'play before preroll'); // 2
      assert.equal(playAfterPreroll, 0, 'play after preroll');
      done();
    }
  });

  this.player.play();
});

_qunit2['default'].test('Event prefixing and prerolls', function (assert) {
  var _this7 = this;

  var done = assert.async();

  var beforePreroll = true;
  var seenInAdMode = [];
  var seenInContentResuming = [];
  var seenOutsideAdModeBefore = [];
  var seenOutsideAdModeAfter = [];

  this.player.on('adend', function () {
    beforePreroll = false;
  });

  var events = ['suspend', 'abort', 'error', 'emptied', 'stalled', 'canplay', 'canplaythrough', 'waiting', 'seeking', 'durationchange', 'timeupdate', 'progress', 'pause', 'ratechange', 'volumechange', 'firstplay', 'suspend'];

  events = events.concat(events.map(function (e) {
    return 'ad' + e;
  }));

  events = events.concat(events.map(function (e) {
    return 'content' + e;
  }));

  this.player.on(events, function (e) {
    var str = e.type;
    if (_this7.player.ads.isInAdMode()) {
      if (_this7.player.ads.isContentResuming()) {
        seenInContentResuming.push(str);
      } else {
        seenInAdMode.push(str);
      }
    } else {
      if (beforePreroll) {
        seenOutsideAdModeBefore.push(str);
      } else {
        seenOutsideAdModeAfter.push(str);
      }
    }
  });

  this.player.on(['error', 'aderror'], function () {
    assert.ok(false, 'no errors');
    done();
  });

  this.player.on('timeupdate', function () {
    if (_this7.player.currentTime() > 1) {

      seenOutsideAdModeBefore.forEach(function (event) {
        assert.ok(!/^ad/.test(event), event + ' has no ad prefix before preroll');
        assert.ok(!/^content/.test(event), event + ' has no content prefix before preroll');
      });

      seenInAdMode.forEach(function (event) {
        assert.ok(/^ad/.test(event), event + ' has ad prefix during preroll');
      });

      seenInContentResuming.forEach(function (event) {
        assert.ok(/^content/.test(event), event + ' has content prefix during preroll');
      });

      seenOutsideAdModeAfter.forEach(function (event) {
        assert.ok(!/^ad/.test(event), event + ' has no ad prefix after preroll');
        assert.ok(!/^content/.test(event), event + ' has no content prefix after preroll');
      });

      done();
    }
  });

  this.player.play();
});

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../example/example-integration.js":1}],12:[function(require,module,exports){
'use strict';

QUnit.module('Ad Macros', window.sharedModuleHooks({}));

QUnit.test('player.id', function (assert) {
  this.player.options_['data-player'] = '12345';
  var result = this.player.ads.adMacroReplacement('{player.id}');

  assert.equal(result, '12345');
});

QUnit.test('mediainfo', function (assert) {
  this.player.mediainfo = {
    id: 1,
    name: 2,
    description: 3,
    tags: 4,
    reference_id: 5,
    duration: 6,
    ad_keys: 7
  };
  var result = this.player.ads.adMacroReplacement('{mediainfo.id}' + '{mediainfo.name}' + '{mediainfo.description}' + '{mediainfo.tags}' + '{mediainfo.reference_id}' + '{mediainfo.duration}' + '{mediainfo.ad_keys}');

  assert.equal(result, '1234567');
});

QUnit.test('player.duration', function (assert) {
  this.player.duration = function () {
    return 5;
  };
  var result = this.player.ads.adMacroReplacement('{player.duration}');

  assert.equal(result, 5);
});

QUnit.test('timestamp', function (assert) {
  this.player.duration = function () {
    return 5;
  };
  var result = this.player.ads.adMacroReplacement('{timestamp}');

  assert.equal(result, new Date().getTime());
});

QUnit.test('document.referrer', function (assert) {
  var result = this.player.ads.adMacroReplacement('{document.referrer}');

  assert.equal(result, document.referrer, '"' + result + '" was the document.referrer');
});

QUnit.test('window.location.href', function (assert) {
  var result = this.player.ads.adMacroReplacement('{window.location.href}');

  assert.equal(result, window.location.href, '"' + result + '" was the window.location.href');
});

QUnit.test('random', function (assert) {
  var result = this.player.ads.adMacroReplacement('{random}');

  assert.ok(result.match(/^\d+$/), '"' + result + '" is a random number');
});

QUnit.test('mediainfo.custom_fields', function (assert) {
  this.player.mediainfo = {
    custom_fields: {
      dog: 1,
      cat: 2,
      guinea_pig: 3
    },
    customFields: {
      dog: 1,
      cat: 2,
      guinea_pig: 3
    }
  };
  var result = this.player.ads.adMacroReplacement('{mediainfo.custom_fields.dog}' + '{mediainfo.custom_fields.cat}' + '{mediainfo.custom_fields.guinea_pig}' + '{mediainfo.customFields.dog}' + '{mediainfo.customFields.cat}' + '{mediainfo.customFields.guinea_pig}');

  assert.equal(result, '123123');
});

QUnit.test('pageVariables', function (assert) {

  window.animal = {
    dog: 'Old Buddy',
    cat: {
      maineCoon: 'Huge the Cat',
      champion: {
        name: 'Champ'
      }
    }
  };
  window.bird = null;
  window.isAwesome = true;
  window.foo = function () {};
  window.bar = {};

  var result = this.player.ads.adMacroReplacement('Number: {pageVariable.scrollX}, ' + 'Boolean: {pageVariable.isAwesome}, ' + 'Null: {pageVariable.bird}, ' + 'Undefined: {pageVariable.thisDoesNotExist}, ' + 'Function: {pageVariable.foo}, ' + 'Object: {pageVariable.bar}, ' + 'Nested 2x: {pageVariable.animal.dog}, ' + 'Nested 3x: {pageVariable.animal.cat.maineCoon}, ' + 'Nested 4x: {pageVariable.animal.cat.champion.name}');

  assert.equal(result, 'Number: 0, ' + 'Boolean: true, ' + 'Null: null, ' + 'Undefined: , ' + 'Function: , ' + 'Object: , ' + 'Nested 2x: Old Buddy, ' + 'Nested 3x: Huge the Cat, ' + 'Nested 4x: Champ');
});

QUnit.test('uriEncode', function (assert) {
  this.player.mediainfo = {
    custom_fields: {
      urlParam: '? &'
    }
  };
  window.foo = '& ?';
  var result = this.player.ads.adMacroReplacement('{mediainfo.custom_fields.urlParam}{pageVariable.foo}', true);

  assert.equal(result, '%3F%20%26%26%20%3F');
});

QUnit.test('customMacros', function (assert) {
  var result = this.player.ads.adMacroReplacement('The sky is {skyColor}. {exclamation}!', false, {
    '{skyColor}': 'blue',
    '{exclamation}': 'Hooray'
  });

  assert.equal(result, 'The sky is blue. Hooray!');
});

},{}],13:[function(require,module,exports){
(function (global){
'use strict';

var _qunit = (typeof window !== "undefined" ? window['QUnit'] : typeof global !== "undefined" ? global['QUnit'] : null);

var _qunit2 = _interopRequireDefault(_qunit);

var _video = (typeof window !== "undefined" ? window['videojs'] : typeof global !== "undefined" ? global['videojs'] : null);

var _video2 = _interopRequireDefault(_video);

var _redispatch = require('../src/redispatch.js');

var _redispatch2 = _interopRequireDefault(_redispatch);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

_qunit2['default'].module('Redispatch', {
  beforeEach: function beforeEach(assert) {

    // Player event buffer.
    // Mocked player pushes events here when they are triggered.
    // redispatch helper returns event buffer after each redispatch.
    var eventBuffer = [];

    // Mocked player
    this.player = {
      trigger: function trigger(event) {
        eventBuffer.push(event);
      },
      currentSrc: function currentSrc() {
        return 'my vid';
      },


      ads: {
        state: 'content-set',

        snapshot: {
          ended: false,
          currentSrc: 'my vid'
        },

        videoElementRecycled: function videoElementRecycled() {
          return false;
        },
        stitchedAds: function stitchedAds() {
          return false;
        }
      }
    };

    // Redispatch helper for tests
    this.redispatch = function (type) {
      var event = { type: type };

      eventBuffer = [];
      _redispatch2['default'].call(this.player, event);

      if (eventBuffer.length === 1) {
        return eventBuffer[0].type;
      } else if (event.cancelBubble) {
        return 'cancelled';
      } else if (eventBuffer.length === 0) {
        return 'ignored';
      } else {
        throw new Error('Event buffer has more than 1 event');
      }
    };
  }
});

_qunit2['default'].test('playing event in different ad states', function (assert) {

  this.player.ads.isInAdMode = function () {
    return false;
  };
  this.player.ads.isContentResuming = function () {
    return false;
  };
  assert.equal(this.redispatch('playing'), 'ignored');

  this.player.ads.isInAdMode = function () {
    return true;
  };
  this.player.ads.isContentResuming = function () {
    return false;
  };
  assert.equal(this.redispatch('playing'), 'adplaying');

  this.player.ads.isInAdMode = function () {
    return true;
  };
  this.player.ads.isContentResuming = function () {
    return true;
  };
  assert.equal(this.redispatch('playing'), 'ignored');
});

_qunit2['default'].test('no adplaying event during ad playback if content play was cancelled', function (assert) {
  this.player.ads.isInAdMode = function () {
    return true;
  };
  this.player.ads.isContentResuming = function () {
    return false;
  };
  this.player.ads._cancelledPlay = true;
  assert.equal(this.redispatch('playing'), 'cancelled');
});

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../src/redispatch.js":3}],14:[function(require,module,exports){
(function (global){
'use strict';

var _video = (typeof window !== "undefined" ? window['videojs'] : typeof global !== "undefined" ? global['videojs'] : null);

var _video2 = _interopRequireDefault(_video);

var _snapshot = require('../src/snapshot.js');

var snapshot = _interopRequireWildcard(_snapshot);

function _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } else { var newObj = {}; if (obj != null) { for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) newObj[key] = obj[key]; } } newObj['default'] = obj; return newObj; } }

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { 'default': obj }; }

QUnit.module('Video Snapshot', window.sharedModuleHooks({

  beforeEach: function beforeEach() {
    var captionTrack = document.createElement('track');
    var otherTrack = document.createElement('track');

    captionTrack.setAttribute('kind', 'captions');
    captionTrack.setAttribute('src', 'testcaption.vtt');
    otherTrack.setAttribute('src', 'testcaption.vtt');
    this.video.appendChild(captionTrack);
    this.video.appendChild(otherTrack);

    this.player.ended = function () {
      return false;
    };
  }
}));

QUnit.test('restores the original video src after ads', function (assert) {
  var originalSrc = 'http://example.com/original.mp4';

  assert.expect(1);

  this.player.src(originalSrc);

  this.player.trigger('adsready');
  this.player.trigger('play');
  this.player.ads.startLinearAdMode();
  this.player.src('//example.com/ad.mp4');
  this.player.ads.endLinearAdMode();
  assert.strictEqual(this.player.currentSrc(), originalSrc, 'the original src is restored');
});

QUnit.test('waits for the video to become seekable before restoring the time', function (assert) {
  var setTimeoutSpy;

  assert.expect(2);

  this.player.trigger('adsready');
  this.player.trigger('play');

  // the video plays to time 100
  setTimeoutSpy = sinon.spy(window, 'setTimeout');
  this.video.currentTime = 100;
  this.player.ads.startLinearAdMode();
  this.player.src('//example.com/ad.mp4');

  // the ad resets the current time
  this.video.currentTime = 0;
  this.player.ads.endLinearAdMode();
  setTimeoutSpy.reset(); // we call setTimeout an extra time restorePlayerSnapshot
  this.player.trigger('canplay');
  assert.strictEqual(setTimeoutSpy.callCount, 1, 'restoring the time should be delayed');
  assert.strictEqual(this.video.currentTime, 0, 'currentTime is not modified');
  window.setTimeout.restore();
});

QUnit.test('the current time is restored at the end of an ad', function (assert) {
  assert.expect(1);

  this.player.trigger('adsready');
  this.video.currentTime = 100;
  this.player.trigger('play');

  // the video plays to time 100
  this.player.ads.startLinearAdMode();
  this.player.src('//example.com/ad.mp4');

  // the ad resets the current time
  this.video.currentTime = 0;
  this.player.ads.endLinearAdMode();
  this.player.trigger('canplay');
  this.clock.tick(1000);
  assert.strictEqual(this.video.currentTime, 100, 'currentTime was restored');
});

QUnit.test('only restores the player snapshot if the src changed', function (assert) {
  var playSpy, srcSpy, currentTimeSpy;

  this.player.trigger('adsready');
  this.player.trigger('play');
  playSpy = sinon.spy(this.player, 'play');
  srcSpy = sinon.spy(this.player, 'src');
  currentTimeSpy = sinon.spy(this.player, 'currentTime');

  // with a separate video display or server-side ad insertion, ads play but
  // the src never changes. Modifying the src or currentTime would introduce
  // unnecessary seeking and rebuffering
  this.player.ads.startLinearAdMode();
  this.player.ads.endLinearAdMode();
  assert.ok(playSpy.called, 'content playback resumed');
  assert.ok(srcSpy.alwaysCalledWithExactly(), 'the src was not reset');

  this.player.trigger('playing');

  // the src wasn't changed, so we shouldn't be waiting on loadedmetadata to
  // update the currentTime
  this.player.trigger('loadedmetadata');
  assert.ok(currentTimeSpy.alwaysCalledWithExactly(), 'no seeking occurred');
});

QUnit.test('snapshot does not resume playback after post-rolls', function (assert) {
  var playSpy = sinon.spy(this.player, 'play');

  // start playback
  this.player.src('http://media.w3.org/2010/05/sintel/trailer.mp4');
  this.player.trigger('loadstart');
  this.player.trigger('loadedmetadata');
  this.player.trigger('adsready');
  this.player.tech_.trigger('play');

  // trigger an ad
  this.player.ads.startLinearAdMode();
  this.player.src('//example.com/ad.mp4');
  this.player.trigger('loadstart');
  this.player.trigger('loadedmetadata');
  this.player.ads.endLinearAdMode();

  // resume playback
  this.player.src('http://media.w3.org/2010/05/sintel/trailer.mp4');
  this.player.trigger('loadstart');
  this.player.trigger('canplay');

  // "canplay" causes the `restorePlayerSnapshot` function in the plugin
  // to be called. This causes content playback to be resumed after 20
  // attempts of a 50ms timeout (20 * 50 == 1000).
  this.clock.tick(1000);
  assert.strictEqual(playSpy.callCount, 1, 'content playback resumed');

  this.player.trigger('playing');

  // if the video ends (regardless of burned in post-roll or otherwise) when
  // stopLinearAdMode fires next we should not hit play() since we have reached
  // the end of the stream
  this.player.ended = function () {
    return true;
  };

  this.player.trigger('ended');
  playSpy.reset();

  // trigger a post-roll
  this.player.ads.startLinearAdMode();
  this.player.src('//example.com/ad.mp4');
  this.player.trigger('loadstart');
  this.player.trigger('loadedmetadata');
  this.player.ads.endLinearAdMode();
  this.player.trigger('playing');
  this.player.trigger('ended');
  assert.strictEqual(this.player.ads.state, 'content-playback', 'Player should be in content-playback state after a post-roll');
  assert.strictEqual(playSpy.callCount, 0, 'content playback should not have been resumed');
});

QUnit.test('snapshot does not resume playback after a burned-in post-roll', function (assert) {
  var playSpy, loadSpy;

  this.player.trigger('adsready');
  this.player.trigger('play');
  playSpy = sinon.spy(this.player, 'play');
  loadSpy = sinon.spy(this.player, 'load');
  this.player.ads.startLinearAdMode();
  this.player.ads.endLinearAdMode();
  this.player.trigger('playing');
  assert.ok(playSpy.called, 'content playback resumed');

  // if the video ends (regardless of burned in post-roll or otherwise) when
  // stopLinearAdMode fires next we should not hit play() since we have reached
  // the end of the stream
  this.player.ended = function () {
    return true;
  };

  this.player.trigger('ended');
  playSpy.reset();

  // trigger a post-roll
  this.player.currentTime(30);
  this.player.ads.startLinearAdMode();
  this.player.currentTime(50);
  this.player.ads.endLinearAdMode();
  this.player.trigger('ended');
  assert.strictEqual(this.player.ads.state, 'content-playback', 'Player should be in content-playback state after a post-roll');
  assert.strictEqual(this.player.currentTime(), 50, 'currentTime should not be reset using burned in ads');
  assert.notOk(loadSpy.called, 'player.load() should not be called if the player is ended.');
  assert.notOk(playSpy.called, 'content playback should not have been resumed');
});

QUnit.test('snapshot does not resume playback after multiple post-rolls', function (assert) {
  var playSpy;

  this.player.src('http://media.w3.org/2010/05/sintel/trailer.mp4');
  this.player.trigger('loadstart');
  this.player.trigger('adsready');
  this.player.trigger('play');
  playSpy = sinon.spy(this.player, 'play');

  // with a separate video display or server-side ad insertion, ads play but
  // the src never changes. Modifying the src or currentTime would introduce
  // unnecessary seeking and rebuffering
  this.player.ads.startLinearAdMode();
  this.player.ads.endLinearAdMode();
  this.player.trigger('playing');
  assert.ok(playSpy.called, 'content playback resumed');

  // if the video ends (regardless of burned in post-roll or otherwise) when
  // stopLinearAdMode fires next we should not hit play() since we have reached
  // the end of the stream
  this.player.ended = function () {
    return true;
  };

  this.player.trigger('ended');
  playSpy.reset();

  // trigger a lot of post-rolls
  this.player.ads.startLinearAdMode();
  this.player.src('http://example.com/ad1.mp4');
  this.player.trigger('loadstart');
  this.player.src('http://example.com/ad2.mp4');
  this.player.trigger('loadstart');
  this.player.ads.endLinearAdMode();
  this.player.trigger('playing');
  this.player.trigger('ended');
  assert.strictEqual(this.player.ads.state, 'content-playback', 'Player should be in content-playback state after a post-roll');
  assert.notOk(playSpy.called, 'content playback should not resume');
});

QUnit.test('changing the source and then timing out does not restore a snapshot', function (assert) {

  this.player.paused = function () {
    return false;
  };

  // load and play the initial video
  this.player.src('http://example.com/movie.mp4');
  this.player.trigger('loadstart');
  this.player.trigger('play');
  this.player.trigger('adsready');

  // preroll
  this.player.ads.startLinearAdMode();
  this.player.ads.endLinearAdMode();
  this.player.trigger('playing');

  // change the content and timeout the new ad response
  this.player.src('http://example.com/movie2.mp4');
  this.player.trigger('loadstart');
  this.player.trigger('adtimeout');
  assert.strictEqual(this.player.ads.state, 'content-playback', 'playing the new content video after the ad timeout');
  assert.strictEqual('http://example.com/movie2.mp4', this.player.currentSrc(), 'playing the second video');
});

// changing the src attribute to a URL that AdBlocker is intercepting
// doesn't update currentSrc, so when restoring the snapshot we
// should check for src attribute modifications as well
QUnit.test('checks for a src attribute change that isn\'t reflected in currentSrc', function (assert) {
  var updatedSrc;

  this.player.currentSrc = function () {
    return 'content.mp4';
  };

  this.player.currentType = function () {
    return 'video/mp4';
  };

  this.player.trigger('adsready');
  this.player.trigger('play');
  this.player.ads.startLinearAdMode();

  // `src` gets called internally to set the source back to its original
  // value when the player snapshot is restored when `endLinearAdMode`
  // is called.
  this.player.tech_.src = function (source) {
    if (source === undefined) {
      return 'ad.mp4';
    }
    updatedSrc = source;
  };

  this.player.src = function (source) {
    if (source === undefined) {
      return 'ad.mp4';
    }
    updatedSrc = source;
  };

  this.player.ads.endLinearAdMode();
  this.player.trigger('playing');
  assert.deepEqual(updatedSrc, { src: 'content.mp4', type: 'video/mp4' }, 'restored src attribute');
});

QUnit.test('When captions are enabled, the video\'s tracks will be disabled during the ad', function (assert) {
  var tracks = this.player.remoteTextTracks ? this.player.remoteTextTracks() : [];
  var showing = 0;
  var disabled = 0;
  var i;

  if (tracks.length <= 0) {
    assert.expect(0);
    _video2['default'].log.warn('Did not detect text track support, skipping');
    return;
  }

  assert.expect(3);
  this.player.trigger('adsready');
  this.player.trigger('play');

  // set all modes to 'showing'
  for (i = 0; i < tracks.length; i++) {
    tracks[i].mode = 'showing';
  }

  for (i = 0; i < tracks.length; i++) {
    if (tracks[i].mode === 'showing') {
      showing++;
    }
  }

  assert.strictEqual(showing, tracks.length, 'all tracks should be showing');
  showing = 0;
  this.player.ads.startLinearAdMode();

  for (i = 0; i < tracks.length; i++) {
    if (tracks[i].mode === 'disabled') {
      disabled++;
    }
  }

  assert.strictEqual(disabled, tracks.length, 'all tracks should be disabled');
  this.player.ads.endLinearAdMode();

  for (i = 0; i < tracks.length; i++) {
    if (tracks[i].mode === 'showing') {
      showing++;
    }
  }

  assert.strictEqual(showing, tracks.length, 'all tracks should be showing');
});

QUnit.test('No snapshot if duration is Infinity', function (assert) {
  var originalSrc = 'foobar';
  var newSrc = 'barbaz';

  this.player.duration(Infinity);

  this.player.src(originalSrc);
  this.player.trigger('adsready');
  this.player.trigger('play');
  this.player.ads.startLinearAdMode();
  this.player.src(newSrc);
  this.player.ads.endLinearAdMode();
  assert.strictEqual(this.player.currentSrc(), newSrc, 'source is not reset');
});

QUnit.test('Snapshot and text tracks', function (assert) {
  var trackSrc = 'http://solutions.brightcove.com/' + 'bcls/captions/adding_captions_to_videos_french.vtt';
  var originalAddTrack = this.player.addTextTrack;
  var originalTextTracks = this.player.textTracks;
  var mockTracks = [];

  // No text tracks at start
  assert.equal(this.player.remoteTextTracks().length, 0);
  assert.equal(this.player.textTracks().length, 0);

  // This is mocked because of native text track behavior
  // which may not have the added track available immediately
  this.player.addTextTrack = function (kind, label, language) {
    mockTracks.push({
      kind: kind,
      label: label,
      language: language,
      mode: 'showing',
      addEventListener: function addEventListener() {}
    });
  };
  this.player.textTracks = function () {
    return mockTracks;
  };

  // Add a text track
  this.player.addRemoteTextTrack({
    kind: 'captions',
    language: 'fr',
    label: 'French',
    src: trackSrc
  });

  this.player.addTextTrack('captions', 'Spanish', 'es');

  // Show our new text track, since it's disabled by default
  this.player.remoteTextTracks()[0].mode = 'showing';

  this.player.textTracks()[0].mode = 'showing';

  // Text track looks good
  assert.equal(this.player.remoteTextTracks().length, 1);
  assert.equal(this.player.remoteTextTrackEls().trackElements_[0].src, trackSrc);
  assert.equal(this.player.remoteTextTracks()[0].kind, 'captions');
  assert.equal(this.player.remoteTextTracks()[0].language, 'fr');
  assert.equal(this.player.remoteTextTracks()[0].mode, 'showing');

  assert.equal(this.player.textTracks().length, 1);
  assert.equal(this.player.textTracks()[0].kind, 'captions');
  assert.equal(this.player.textTracks()[0].language, 'es');
  assert.equal(this.player.textTracks()[0].mode, 'showing');

  // Do a snapshot, as if an ad is starting
  this.player.ads.snapshot = snapshot.getPlayerSnapshot(this.player);

  // Snapshot reflects the text track
  assert.equal(this.player.ads.snapshot.suppressedRemoteTracks.length, 1);
  assert.equal(this.player.ads.snapshot.suppressedRemoteTracks[0].track.kind, 'captions');
  assert.equal(this.player.ads.snapshot.suppressedRemoteTracks[0].track.language, 'fr');
  assert.equal(this.player.ads.snapshot.suppressedRemoteTracks[0].mode, 'showing');

  assert.equal(this.player.ads.snapshot.suppressedTracks.length, 1);
  assert.equal(this.player.ads.snapshot.suppressedTracks[0].track.kind, 'captions');
  assert.equal(this.player.ads.snapshot.suppressedTracks[0].track.language, 'es');
  assert.equal(this.player.ads.snapshot.suppressedTracks[0].mode, 'showing');

  // Meanwhile, track is intact, just disabled
  assert.equal(this.player.remoteTextTracks().length, 1);
  assert.equal(this.player.remoteTextTrackEls().trackElements_[0].src, trackSrc);
  assert.equal(this.player.remoteTextTracks()[0].kind, 'captions');
  assert.equal(this.player.remoteTextTracks()[0].language, 'fr');
  assert.equal(this.player.remoteTextTracks()[0].mode, 'disabled');

  assert.equal(this.player.textTracks().length, 1);
  assert.equal(this.player.textTracks()[0].kind, 'captions');
  assert.equal(this.player.textTracks()[0].language, 'es');
  assert.equal(this.player.textTracks()[0].mode, 'disabled');

  // Restore the snapshot, as if an ad is ending
  snapshot.restorePlayerSnapshot(this.player, this.player.ads.snapshot);

  // Everything is back to normal
  assert.equal(this.player.remoteTextTracks().length, 1);
  assert.equal(this.player.remoteTextTrackEls().trackElements_[0].src, trackSrc);
  assert.equal(this.player.remoteTextTracks()[0].kind, 'captions');
  assert.equal(this.player.remoteTextTracks()[0].language, 'fr');
  assert.equal(this.player.remoteTextTracks()[0].mode, 'showing');

  assert.equal(this.player.textTracks().length, 1);
  assert.equal(this.player.textTracks()[0].kind, 'captions');
  assert.equal(this.player.textTracks()[0].language, 'es');
  assert.equal(this.player.textTracks()[0].mode, 'showing');

  // Resetting mocked methods
  this.player.addTextTrack = originalAddTrack;
  this.player.textTracks = originalTextTracks;
});

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{"../src/snapshot.js":4}]},{},[5,6,7,8,9,10,11,12,13,14]);
